/*! For license information please see 2743.0b450632.iframe.bundle.js.LICENSE.txt */
(self.webpackChunkxterio=self.webpackChunkxterio||[]).push([[2743],{"./node_modules/@babel/runtime/helpers/assertThisInitialized.js":module=>{module.exports=function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return self},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/asyncToGenerator.js":module=>{function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}module.exports=function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/classCallCheck.js":module=>{module.exports=function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/createClass.js":(module,__unused_webpack_exports,__webpack_require__)=>{var toPropertyKey=__webpack_require__("./node_modules/@babel/runtime/helpers/toPropertyKey.js");function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,toPropertyKey(descriptor.key),descriptor)}}module.exports=function _createClass(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/getPrototypeOf.js":module=>{function _getPrototypeOf(o){return module.exports=_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o)},module.exports.__esModule=!0,module.exports.default=module.exports,_getPrototypeOf(o)}module.exports=_getPrototypeOf,module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/inherits.js":(module,__unused_webpack_exports,__webpack_require__)=>{var setPrototypeOf=__webpack_require__("./node_modules/@babel/runtime/helpers/setPrototypeOf.js");module.exports=function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}}),Object.defineProperty(subClass,"prototype",{writable:!1}),superClass&&setPrototypeOf(subClass,superClass)},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/interopRequireDefault.js":module=>{module.exports=function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js").default,assertThisInitialized=__webpack_require__("./node_modules/@babel/runtime/helpers/assertThisInitialized.js");module.exports=function _possibleConstructorReturn(self,call){if(call&&("object"===_typeof(call)||"function"==typeof call))return call;if(void 0!==call)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(self)},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/setPrototypeOf.js":module=>{function _setPrototypeOf(o,p){return module.exports=_setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(o,p){return o.__proto__=p,o},module.exports.__esModule=!0,module.exports.default=module.exports,_setPrototypeOf(o,p)}module.exports=_setPrototypeOf,module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/toPrimitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js").default;module.exports=function toPrimitive(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/toPropertyKey.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js").default,toPrimitive=__webpack_require__("./node_modules/@babel/runtime/helpers/toPrimitive.js");module.exports=function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+""},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@solana/buffer-layout/lib/Layout.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";exports._O=exports.Jq=exports.KB=exports.u8=exports.cv=void 0,exports.Ik=exports.A9=exports.n_=exports.gM=void 0;const buffer_1=__webpack_require__("./node_modules/buffer/index.js");function checkUint8Array(b){if(!(b instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function uint8ArrayToBuffer(b){return checkUint8Array(b),buffer_1.Buffer.from(b.buffer,b.byteOffset,b.length)}class Layout{constructor(span,property){if(!Number.isInteger(span))throw new TypeError("span must be an integer");this.span=span,this.property=property}makeDestinationObject(){return{}}getSpan(b,offset){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(property){const rv=Object.create(this.constructor.prototype);return Object.assign(rv,this),rv.property=property,rv}fromArray(values){}}function nameWithProperty(name,lo){return lo.property?name+"["+lo.property+"]":name}class ExternalLayout extends Layout{isCount(){throw new Error("ExternalLayout is abstract")}}class GreedyCount extends ExternalLayout{constructor(elementSpan=1,property){if(!Number.isInteger(elementSpan)||0>=elementSpan)throw new TypeError("elementSpan must be a (positive) integer");super(-1,property),this.elementSpan=elementSpan}isCount(){return!0}decode(b,offset=0){checkUint8Array(b);const rem=b.length-offset;return Math.floor(rem/this.elementSpan)}encode(src,b,offset){return 0}}class OffsetLayout extends ExternalLayout{constructor(layout,offset=0,property){if(!(layout instanceof Layout))throw new TypeError("layout must be a Layout");if(!Number.isInteger(offset))throw new TypeError("offset must be integer or undefined");super(layout.span,property||layout.property),this.layout=layout,this.offset=offset}isCount(){return this.layout instanceof UInt||this.layout instanceof UIntBE}decode(b,offset=0){return this.layout.decode(b,offset+this.offset)}encode(src,b,offset=0){return this.layout.encode(src,b,offset+this.offset)}}class UInt extends Layout{constructor(span,property){if(super(span,property),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(b,offset=0){return uint8ArrayToBuffer(b).readUIntLE(offset,this.span)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeUIntLE(src,offset,this.span),this.span}}class UIntBE extends Layout{constructor(span,property){if(super(span,property),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(b,offset=0){return uint8ArrayToBuffer(b).readUIntBE(offset,this.span)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeUIntBE(src,offset,this.span),this.span}}class Int extends Layout{constructor(span,property){if(super(span,property),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(b,offset=0){return uint8ArrayToBuffer(b).readIntLE(offset,this.span)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeIntLE(src,offset,this.span),this.span}}class IntBE extends Layout{constructor(span,property){if(super(span,property),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(b,offset=0){return uint8ArrayToBuffer(b).readIntBE(offset,this.span)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeIntBE(src,offset,this.span),this.span}}const V2E32=Math.pow(2,32);function divmodInt64(src){const hi32=Math.floor(src/V2E32);return{hi32,lo32:src-hi32*V2E32}}function roundedInt64(hi32,lo32){return hi32*V2E32+lo32}class NearUInt64 extends Layout{constructor(property){super(8,property)}decode(b,offset=0){const buffer=uint8ArrayToBuffer(b),lo32=buffer.readUInt32LE(offset);return roundedInt64(buffer.readUInt32LE(offset+4),lo32)}encode(src,b,offset=0){const split=divmodInt64(src),buffer=uint8ArrayToBuffer(b);return buffer.writeUInt32LE(split.lo32,offset),buffer.writeUInt32LE(split.hi32,offset+4),8}}class NearUInt64BE extends Layout{constructor(property){super(8,property)}decode(b,offset=0){const buffer=uint8ArrayToBuffer(b);return roundedInt64(buffer.readUInt32BE(offset),buffer.readUInt32BE(offset+4))}encode(src,b,offset=0){const split=divmodInt64(src),buffer=uint8ArrayToBuffer(b);return buffer.writeUInt32BE(split.hi32,offset),buffer.writeUInt32BE(split.lo32,offset+4),8}}class NearInt64 extends Layout{constructor(property){super(8,property)}decode(b,offset=0){const buffer=uint8ArrayToBuffer(b),lo32=buffer.readUInt32LE(offset);return roundedInt64(buffer.readInt32LE(offset+4),lo32)}encode(src,b,offset=0){const split=divmodInt64(src),buffer=uint8ArrayToBuffer(b);return buffer.writeUInt32LE(split.lo32,offset),buffer.writeInt32LE(split.hi32,offset+4),8}}class NearInt64BE extends Layout{constructor(property){super(8,property)}decode(b,offset=0){const buffer=uint8ArrayToBuffer(b);return roundedInt64(buffer.readInt32BE(offset),buffer.readUInt32BE(offset+4))}encode(src,b,offset=0){const split=divmodInt64(src),buffer=uint8ArrayToBuffer(b);return buffer.writeInt32BE(split.hi32,offset),buffer.writeUInt32BE(split.lo32,offset+4),8}}class Float extends Layout{constructor(property){super(4,property)}decode(b,offset=0){return uint8ArrayToBuffer(b).readFloatLE(offset)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeFloatLE(src,offset),4}}class FloatBE extends Layout{constructor(property){super(4,property)}decode(b,offset=0){return uint8ArrayToBuffer(b).readFloatBE(offset)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeFloatBE(src,offset),4}}class Double extends Layout{constructor(property){super(8,property)}decode(b,offset=0){return uint8ArrayToBuffer(b).readDoubleLE(offset)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeDoubleLE(src,offset),8}}class DoubleBE extends Layout{constructor(property){super(8,property)}decode(b,offset=0){return uint8ArrayToBuffer(b).readDoubleBE(offset)}encode(src,b,offset=0){return uint8ArrayToBuffer(b).writeDoubleBE(src,offset),8}}class Sequence extends Layout{constructor(elementLayout,count,property){if(!(elementLayout instanceof Layout))throw new TypeError("elementLayout must be a Layout");if(!(count instanceof ExternalLayout&&count.isCount()||Number.isInteger(count)&&0<=count))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let span=-1;!(count instanceof ExternalLayout)&&0<elementLayout.span&&(span=count*elementLayout.span),super(span,property),this.elementLayout=elementLayout,this.count=count}getSpan(b,offset=0){if(0<=this.span)return this.span;let span=0,count=this.count;if(count instanceof ExternalLayout&&(count=count.decode(b,offset)),0<this.elementLayout.span)span=count*this.elementLayout.span;else{let idx=0;for(;idx<count;)span+=this.elementLayout.getSpan(b,offset+span),++idx}return span}decode(b,offset=0){const rv=[];let i=0,count=this.count;for(count instanceof ExternalLayout&&(count=count.decode(b,offset));i<count;)rv.push(this.elementLayout.decode(b,offset)),offset+=this.elementLayout.getSpan(b,offset),i+=1;return rv}encode(src,b,offset=0){const elo=this.elementLayout,span=src.reduce(((span,v)=>span+elo.encode(v,b,offset+span)),0);return this.count instanceof ExternalLayout&&this.count.encode(src.length,b,offset),span}}class Structure extends Layout{constructor(fields,property,decodePrefixes){if(!Array.isArray(fields)||!fields.reduce(((acc,v)=>acc&&v instanceof Layout),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof property&&void 0===decodePrefixes&&(decodePrefixes=property,property=void 0);for(const fd of fields)if(0>fd.span&&void 0===fd.property)throw new Error("fields cannot contain unnamed variable-length layout");let span=-1;try{span=fields.reduce(((span,fd)=>span+fd.getSpan()),0)}catch(e){}super(span,property),this.fields=fields,this.decodePrefixes=!!decodePrefixes}getSpan(b,offset=0){if(0<=this.span)return this.span;let span=0;try{span=this.fields.reduce(((span,fd)=>{const fsp=fd.getSpan(b,offset);return offset+=fsp,span+fsp}),0)}catch(e){throw new RangeError("indeterminate span")}return span}decode(b,offset=0){checkUint8Array(b);const dest=this.makeDestinationObject();for(const fd of this.fields)if(void 0!==fd.property&&(dest[fd.property]=fd.decode(b,offset)),offset+=fd.getSpan(b,offset),this.decodePrefixes&&b.length===offset)break;return dest}encode(src,b,offset=0){const firstOffset=offset;let lastOffset=0,lastWrote=0;for(const fd of this.fields){let span=fd.span;if(lastWrote=0<span?span:0,void 0!==fd.property){const fv=src[fd.property];void 0!==fv&&(lastWrote=fd.encode(fv,b,offset),0>span&&(span=fd.getSpan(b,offset)))}lastOffset=offset,offset+=span}return lastOffset+lastWrote-firstOffset}fromArray(values){const dest=this.makeDestinationObject();for(const fd of this.fields)void 0!==fd.property&&0<values.length&&(dest[fd.property]=values.shift());return dest}layoutFor(property){if("string"!=typeof property)throw new TypeError("property must be string");for(const fd of this.fields)if(fd.property===property)return fd}offsetOf(property){if("string"!=typeof property)throw new TypeError("property must be string");let offset=0;for(const fd of this.fields){if(fd.property===property)return offset;0>fd.span?offset=-1:0<=offset&&(offset+=fd.span)}}}class UnionDiscriminator{constructor(property){this.property=property}decode(b,offset){throw new Error("UnionDiscriminator is abstract")}encode(src,b,offset){throw new Error("UnionDiscriminator is abstract")}}class UnionLayoutDiscriminator extends UnionDiscriminator{constructor(layout,property){if(!(layout instanceof ExternalLayout&&layout.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(property||layout.property||"variant"),this.layout=layout}decode(b,offset){return this.layout.decode(b,offset)}encode(src,b,offset){return this.layout.encode(src,b,offset)}}class Union extends Layout{constructor(discr,defaultLayout,property){let discriminator;if(discr instanceof UInt||discr instanceof UIntBE)discriminator=new UnionLayoutDiscriminator(new OffsetLayout(discr));else if(discr instanceof ExternalLayout&&discr.isCount())discriminator=new UnionLayoutDiscriminator(discr);else{if(!(discr instanceof UnionDiscriminator))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");discriminator=discr}if(void 0===defaultLayout&&(defaultLayout=null),!(null===defaultLayout||defaultLayout instanceof Layout))throw new TypeError("defaultLayout must be null or a Layout");if(null!==defaultLayout){if(0>defaultLayout.span)throw new Error("defaultLayout must have constant span");void 0===defaultLayout.property&&(defaultLayout=defaultLayout.replicate("content"))}let span=-1;defaultLayout&&(span=defaultLayout.span,0<=span&&(discr instanceof UInt||discr instanceof UIntBE)&&(span+=discriminator.layout.span)),super(span,property),this.discriminator=discriminator,this.usesPrefixDiscriminator=discr instanceof UInt||discr instanceof UIntBE,this.defaultLayout=defaultLayout,this.registry={};let boundGetSourceVariant=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(src){return boundGetSourceVariant(src)},this.configGetSourceVariant=function(gsv){boundGetSourceVariant=gsv.bind(this)}}getSpan(b,offset=0){if(0<=this.span)return this.span;const vlo=this.getVariant(b,offset);if(!vlo)throw new Error("unable to determine span for unrecognized variant");return vlo.getSpan(b,offset)}defaultGetSourceVariant(src){if(Object.prototype.hasOwnProperty.call(src,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(src,this.defaultLayout.property))return;const vlo=this.registry[src[this.discriminator.property]];if(vlo&&(!vlo.layout||vlo.property&&Object.prototype.hasOwnProperty.call(src,vlo.property)))return vlo}else for(const tag in this.registry){const vlo=this.registry[tag];if(vlo.property&&Object.prototype.hasOwnProperty.call(src,vlo.property))return vlo}throw new Error("unable to infer src variant")}decode(b,offset=0){let dest;const dlo=this.discriminator,discr=dlo.decode(b,offset),clo=this.registry[discr];if(void 0===clo){const defaultLayout=this.defaultLayout;let contentOffset=0;this.usesPrefixDiscriminator&&(contentOffset=dlo.layout.span),dest=this.makeDestinationObject(),dest[dlo.property]=discr,dest[defaultLayout.property]=defaultLayout.decode(b,offset+contentOffset)}else dest=clo.decode(b,offset);return dest}encode(src,b,offset=0){const vlo=this.getSourceVariant(src);if(void 0===vlo){const dlo=this.discriminator,clo=this.defaultLayout;let contentOffset=0;return this.usesPrefixDiscriminator&&(contentOffset=dlo.layout.span),dlo.encode(src[dlo.property],b,offset),contentOffset+clo.encode(src[clo.property],b,offset+contentOffset)}return vlo.encode(src,b,offset)}addVariant(variant,layout,property){const rv=new VariantLayout(this,variant,layout,property);return this.registry[variant]=rv,rv}getVariant(vb,offset=0){let variant;return variant=vb instanceof Uint8Array?this.discriminator.decode(vb,offset):vb,this.registry[variant]}}class VariantLayout extends Layout{constructor(union,variant,layout,property){if(!(union instanceof Union))throw new TypeError("union must be a Union");if(!Number.isInteger(variant)||0>variant)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof layout&&void 0===property&&(property=layout,layout=null),layout){if(!(layout instanceof Layout))throw new TypeError("layout must be a Layout");if(null!==union.defaultLayout&&0<=layout.span&&layout.span>union.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof property)throw new TypeError("variant must have a String property")}let span=union.span;0>union.span&&(span=layout?layout.span:0,0<=span&&union.usesPrefixDiscriminator&&(span+=union.discriminator.layout.span)),super(span,property),this.union=union,this.variant=variant,this.layout=layout||null}getSpan(b,offset=0){if(0<=this.span)return this.span;let contentOffset=0;this.union.usesPrefixDiscriminator&&(contentOffset=this.union.discriminator.layout.span);let span=0;return this.layout&&(span=this.layout.getSpan(b,offset+contentOffset)),contentOffset+span}decode(b,offset=0){const dest=this.makeDestinationObject();if(this!==this.union.getVariant(b,offset))throw new Error("variant mismatch");let contentOffset=0;return this.union.usesPrefixDiscriminator&&(contentOffset=this.union.discriminator.layout.span),this.layout?dest[this.property]=this.layout.decode(b,offset+contentOffset):this.property?dest[this.property]=!0:this.union.usesPrefixDiscriminator&&(dest[this.union.discriminator.property]=this.variant),dest}encode(src,b,offset=0){let contentOffset=0;if(this.union.usesPrefixDiscriminator&&(contentOffset=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(src,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,b,offset);let span=contentOffset;if(this.layout&&(this.layout.encode(src[this.property],b,offset+contentOffset),span+=this.layout.getSpan(b,offset+contentOffset),0<=this.union.span&&span>this.union.span))throw new Error("encoded variant overruns containing union");return span}fromArray(values){if(this.layout)return this.layout.fromArray(values)}}function fixBitwiseResult(v){return 0>v&&(v+=4294967296),v}class BitStructure extends Layout{constructor(word,msb,property){if(!(word instanceof UInt||word instanceof UIntBE))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof msb&&void 0===property&&(property=msb,msb=!1),4<word.span)throw new RangeError("word cannot exceed 32 bits");super(word.span,property),this.word=word,this.msb=!!msb,this.fields=[];let value=0;this._packedSetValue=function(v){return value=fixBitwiseResult(v),this},this._packedGetValue=function(){return value}}decode(b,offset=0){const dest=this.makeDestinationObject(),value=this.word.decode(b,offset);this._packedSetValue(value);for(const fd of this.fields)void 0!==fd.property&&(dest[fd.property]=fd.decode(b));return dest}encode(src,b,offset=0){const value=this.word.decode(b,offset);this._packedSetValue(value);for(const fd of this.fields)if(void 0!==fd.property){const fv=src[fd.property];void 0!==fv&&fd.encode(fv)}return this.word.encode(this._packedGetValue(),b,offset)}addField(bits,property){const bf=new BitField(this,bits,property);return this.fields.push(bf),bf}addBoolean(property){const bf=new Boolean(this,property);return this.fields.push(bf),bf}fieldFor(property){if("string"!=typeof property)throw new TypeError("property must be string");for(const fd of this.fields)if(fd.property===property)return fd}}class BitField{constructor(container,bits,property){if(!(container instanceof BitStructure))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(bits)||0>=bits)throw new TypeError("bits must be positive integer");const totalBits=8*container.span,usedBits=container.fields.reduce(((sum,fd)=>sum+fd.bits),0);if(bits+usedBits>totalBits)throw new Error("bits too long for span remainder ("+(totalBits-usedBits)+" of "+totalBits+" remain)");this.container=container,this.bits=bits,this.valueMask=(1<<bits)-1,32===bits&&(this.valueMask=4294967295),this.start=usedBits,this.container.msb&&(this.start=totalBits-usedBits-bits),this.wordMask=fixBitwiseResult(this.valueMask<<this.start),this.property=property}decode(b,offset){return fixBitwiseResult(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(value){if("number"!=typeof value||!Number.isInteger(value)||value!==fixBitwiseResult(value&this.valueMask))throw new TypeError(nameWithProperty("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const word=this.container._packedGetValue(),wordValue=fixBitwiseResult(value<<this.start);this.container._packedSetValue(fixBitwiseResult(word&~this.wordMask)|wordValue)}}class Boolean extends BitField{constructor(container,property){super(container,1,property)}decode(b,offset){return!!super.decode(b,offset)}encode(value){"boolean"==typeof value&&(value=+value),super.encode(value)}}class Blob extends Layout{constructor(length,property){if(!(length instanceof ExternalLayout&&length.isCount()||Number.isInteger(length)&&0<=length))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let span=-1;length instanceof ExternalLayout||(span=length),super(span,property),this.length=length}getSpan(b,offset){let span=this.span;return 0>span&&(span=this.length.decode(b,offset)),span}decode(b,offset=0){let span=this.span;return 0>span&&(span=this.length.decode(b,offset)),uint8ArrayToBuffer(b).slice(offset,offset+span)}encode(src,b,offset){let span=this.length;if(this.length instanceof ExternalLayout&&(span=src.length),!(src instanceof Uint8Array&&span===src.length))throw new TypeError(nameWithProperty("Blob.encode",this)+" requires (length "+span+") Uint8Array as src");if(offset+span>b.length)throw new RangeError("encoding overruns Uint8Array");const srcBuffer=uint8ArrayToBuffer(src);return uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"),offset,span,"hex"),this.length instanceof ExternalLayout&&this.length.encode(span,b,offset),span}}class CString extends Layout{constructor(property){super(-1,property)}getSpan(b,offset=0){checkUint8Array(b);let idx=offset;for(;idx<b.length&&0!==b[idx];)idx+=1;return 1+idx-offset}decode(b,offset=0){const span=this.getSpan(b,offset);return uint8ArrayToBuffer(b).slice(offset,offset+span-1).toString("utf-8")}encode(src,b,offset=0){"string"!=typeof src&&(src=String(src));const srcb=buffer_1.Buffer.from(src,"utf8"),span=srcb.length;if(offset+span>b.length)throw new RangeError("encoding overruns Buffer");const buffer=uint8ArrayToBuffer(b);return srcb.copy(buffer,offset),buffer[offset+span]=0,span+1}}class UTF8 extends Layout{constructor(maxSpan,property){if("string"==typeof maxSpan&&void 0===property&&(property=maxSpan,maxSpan=void 0),void 0===maxSpan)maxSpan=-1;else if(!Number.isInteger(maxSpan))throw new TypeError("maxSpan must be an integer");super(-1,property),this.maxSpan=maxSpan}getSpan(b,offset=0){return checkUint8Array(b),b.length-offset}decode(b,offset=0){const span=this.getSpan(b,offset);if(0<=this.maxSpan&&this.maxSpan<span)throw new RangeError("text length exceeds maxSpan");return uint8ArrayToBuffer(b).slice(offset,offset+span).toString("utf-8")}encode(src,b,offset=0){"string"!=typeof src&&(src=String(src));const srcb=buffer_1.Buffer.from(src,"utf8"),span=srcb.length;if(0<=this.maxSpan&&this.maxSpan<span)throw new RangeError("text length exceeds maxSpan");if(offset+span>b.length)throw new RangeError("encoding overruns Buffer");return srcb.copy(uint8ArrayToBuffer(b),offset),span}}class Constant extends Layout{constructor(value,property){super(0,property),this.value=value}decode(b,offset){return this.value}encode(src,b,offset){return 0}}exports.cv=(layout,offset,property)=>new OffsetLayout(layout,offset,property),exports.u8=property=>new UInt(1,property),exports.KB=property=>new UInt(2,property),exports.Jq=property=>new UInt(4,property),exports._O=property=>new NearUInt64(property),exports.gM=property=>new NearInt64(property),exports.n_=(fields,property,decodePrefixes)=>new Structure(fields,property,decodePrefixes),exports.A9=(elementLayout,count,property)=>new Sequence(elementLayout,count,property),exports.Ik=(length,property)=>new Blob(length,property)},"./node_modules/@solana/web3.js/lib/index.browser.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{PublicKey:()=>PublicKey,VersionedTransaction:()=>VersionedTransaction});var abstract_utils_namespaceObject={};__webpack_require__.r(abstract_utils_namespaceObject),__webpack_require__.d(abstract_utils_namespaceObject,{gk:()=>utils_abytes,dQ:()=>bitMask,ci:()=>abstract_utils_bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,ty:()=>utils_bytesToNumberLE,eV:()=>abstract_utils_concatBytes,n$:()=>createHmacDrbg,ql:()=>utils_ensureBytes,hexToBytes:()=>utils_hexToBytes,_t:()=>abstract_utils_isBytes,tL:()=>utils_numberToBytesBE,S5:()=>utils_numberToBytesLE,FF:()=>validateObject});var node_modules_buffer=__webpack_require__("./node_modules/buffer/index.js");function _assert_number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bytes(b,...lengths){if(!function isBytes(a){return a instanceof Uint8Array||null!=a&&"object"==typeof a&&"Uint8Array"===a.constructor.name}(b))throw new Error("Uint8Array expected");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`)}function _assert_hash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");_assert_number(h.outputLen),_assert_number(h.blockLen)}function exists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min)throw new Error(`digestInto() expects output buffer of length at least ${min}`)}const crypto_crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength),rotr=(word,shift)=>word<<32-shift|word>>>shift,isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255;function byteSwap32(arr){for(let i=0;i<arr.length;i++)arr[i]=byteSwap(arr[i])}function utils_utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){return"string"==typeof data&&(data=utils_utf8ToBytes(data)),bytes(data),data}function utils_concatBytes(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];bytes(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res}class Hash{clone(){return this._cloneInto()}}function utils_wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}function utils_randomBytes(bytesLength=32){if(crypto_crypto&&"function"==typeof crypto_crypto.getRandomValues)return crypto_crypto.getRandomValues(new Uint8Array(bytesLength));throw new Error("crypto.getRandomValues must be defined")}const Maj=(a,b,c)=>a&b^a&c^b&c;class HashMD extends Hash{constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=createView(this.buffer)}update(data){exists(this);const{view,buffer,blockLen}=this,len=(data=toBytes(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){exists(this),output(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function setBigUint64(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=createView(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}}const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s,rotlSL=(h,l,s)=>l<<s|h>>>32-s,rotlBH=(h,l,s)=>l<<s-32|h>>>64-s,rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const _u64={fromBig,split,toBig:(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0),shrSH:(h,_l,s)=>h>>>s,shrSL:(h,l,s)=>h<<32-s|l>>>s,rotrSH:(h,l,s)=>h>>>s|l<<32-s,rotrSL:(h,l,s)=>h<<32-s|l>>>s,rotrBH:(h,l,s)=>h<<64-s|l>>>s-32,rotrBL:(h,l,s)=>h>>>s-32|l<<64-s,rotr32H:(_h,l)=>l,rotr32L:(h,_l)=>h,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}},add3L:(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0),add3H:(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0,add4L:(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0),add4H:(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0,add5H:(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0,add5L:(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0)},[SHA512_Kh,SHA512_Kl]=(()=>_u64.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((n=>BigInt(n)))))(),SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80);class SHA512 extends HashMD{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;return[Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl]}set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl){this.Ah=0|Ah,this.Al=0|Al,this.Bh=0|Bh,this.Bl=0|Bl,this.Ch=0|Ch,this.Cl=0|Cl,this.Dh=0|Dh,this.Dl=0|Dl,this.Eh=0|Eh,this.El=0|El,this.Fh=0|Fh,this.Fl=0|Fl,this.Gh=0|Gh,this.Gl=0|Gl,this.Hh=0|Hh,this.Hl=0|Hl}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA512_W_H[i]=view.getUint32(offset),SHA512_W_L[i]=view.getUint32(offset+=4);for(let i=16;i<80;i++){const W15h=0|SHA512_W_H[i-15],W15l=0|SHA512_W_L[i-15],s0h=_u64.rotrSH(W15h,W15l,1)^_u64.rotrSH(W15h,W15l,8)^_u64.shrSH(W15h,W15l,7),s0l=_u64.rotrSL(W15h,W15l,1)^_u64.rotrSL(W15h,W15l,8)^_u64.shrSL(W15h,W15l,7),W2h=0|SHA512_W_H[i-2],W2l=0|SHA512_W_L[i-2],s1h=_u64.rotrSH(W2h,W2l,19)^_u64.rotrBH(W2h,W2l,61)^_u64.shrSH(W2h,W2l,6),s1l=_u64.rotrSL(W2h,W2l,19)^_u64.rotrBL(W2h,W2l,61)^_u64.shrSL(W2h,W2l,6),SUMl=_u64.add4L(s0l,s1l,SHA512_W_L[i-7],SHA512_W_L[i-16]),SUMh=_u64.add4H(SUMl,s0h,s1h,SHA512_W_H[i-7],SHA512_W_H[i-16]);SHA512_W_H[i]=0|SUMh,SHA512_W_L[i]=0|SUMl}let{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;for(let i=0;i<80;i++){const sigma1h=_u64.rotrSH(Eh,El,14)^_u64.rotrSH(Eh,El,18)^_u64.rotrBH(Eh,El,41),sigma1l=_u64.rotrSL(Eh,El,14)^_u64.rotrSL(Eh,El,18)^_u64.rotrBL(Eh,El,41),CHIh=Eh&Fh^~Eh&Gh,CHIl=El&Fl^~El&Gl,T1ll=_u64.add5L(Hl,sigma1l,CHIl,SHA512_Kl[i],SHA512_W_L[i]),T1h=_u64.add5H(T1ll,Hh,sigma1h,CHIh,SHA512_Kh[i],SHA512_W_H[i]),T1l=0|T1ll,sigma0h=_u64.rotrSH(Ah,Al,28)^_u64.rotrBH(Ah,Al,34)^_u64.rotrBH(Ah,Al,39),sigma0l=_u64.rotrSL(Ah,Al,28)^_u64.rotrBL(Ah,Al,34)^_u64.rotrBL(Ah,Al,39),MAJh=Ah&Bh^Ah&Ch^Bh&Ch,MAJl=Al&Bl^Al&Cl^Bl&Cl;Hh=0|Gh,Hl=0|Gl,Gh=0|Fh,Gl=0|Fl,Fh=0|Eh,Fl=0|El,({h:Eh,l:El}=_u64.add(0|Dh,0|Dl,0|T1h,0|T1l)),Dh=0|Ch,Dl=0|Cl,Ch=0|Bh,Cl=0|Bl,Bh=0|Ah,Bl=0|Al;const All=_u64.add3L(T1l,sigma0l,MAJl);Ah=_u64.add3H(All,T1h,sigma0h,MAJh),Al=0|All}({h:Ah,l:Al}=_u64.add(0|this.Ah,0|this.Al,0|Ah,0|Al)),({h:Bh,l:Bl}=_u64.add(0|this.Bh,0|this.Bl,0|Bh,0|Bl)),({h:Ch,l:Cl}=_u64.add(0|this.Ch,0|this.Cl,0|Ch,0|Cl)),({h:Dh,l:Dl}=_u64.add(0|this.Dh,0|this.Dl,0|Dh,0|Dl)),({h:Eh,l:El}=_u64.add(0|this.Eh,0|this.El,0|Eh,0|El)),({h:Fh,l:Fl}=_u64.add(0|this.Fh,0|this.Fl,0|Fh,0|Fl)),({h:Gh,l:Gl}=_u64.add(0|this.Gh,0|this.Gl,0|Gh,0|Gl)),({h:Hh,l:Hl}=_u64.add(0|this.Hh,0|this.Hl,0|Hh,0|Hl)),this.set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl)}roundClean(){SHA512_W_H.fill(0),SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const sha512_sha512=utils_wrapConstructor((()=>new SHA512)),_1n=(BigInt(0),BigInt(1)),_2n=BigInt(2);function abstract_utils_isBytes(a){return a instanceof Uint8Array||null!=a&&"object"==typeof a&&"Uint8Array"===a.constructor.name}function utils_abytes(item){if(!abstract_utils_isBytes(item))throw new Error("Uint8Array expected")}const utils_hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));function abstract_utils_bytesToHex(bytes){utils_abytes(bytes);let hex="";for(let i=0;i<bytes.length;i++)hex+=utils_hexes[bytes[i]];return hex}function hexToNumber(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);return BigInt(""===hex?"0":`0x${hex}`)}const utils_asciis={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function utils_asciiToBase16(char){return char>=utils_asciis._0&&char<=utils_asciis._9?char-utils_asciis._0:char>=utils_asciis._A&&char<=utils_asciis._F?char-(utils_asciis._A-10):char>=utils_asciis._a&&char<=utils_asciis._f?char-(utils_asciis._a-10):void 0}function utils_hexToBytes(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const hl=hex.length,al=hl/2;if(hl%2)throw new Error("padded hex string expected, got unpadded hex of length "+hl);const array=new Uint8Array(al);for(let ai=0,hi=0;ai<al;ai++,hi+=2){const n1=utils_asciiToBase16(hex.charCodeAt(hi)),n2=utils_asciiToBase16(hex.charCodeAt(hi+1));if(void 0===n1||void 0===n2){const char=hex[hi]+hex[hi+1];throw new Error('hex string expected, got non-hex character "'+char+'" at index '+hi)}array[ai]=16*n1+n2}return array}function utils_bytesToNumberBE(bytes){return hexToNumber(abstract_utils_bytesToHex(bytes))}function utils_bytesToNumberLE(bytes){return utils_abytes(bytes),hexToNumber(abstract_utils_bytesToHex(Uint8Array.from(bytes).reverse()))}function utils_numberToBytesBE(n,len){return utils_hexToBytes(n.toString(16).padStart(2*len,"0"))}function utils_numberToBytesLE(n,len){return utils_numberToBytesBE(n,len).reverse()}function utils_ensureBytes(title,hex,expectedLength){let res;if("string"==typeof hex)try{res=utils_hexToBytes(hex)}catch(e){throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`)}else{if(!abstract_utils_isBytes(hex))throw new Error(`${title} must be hex string or Uint8Array`);res=Uint8Array.from(hex)}const len=res.length;if("number"==typeof expectedLength&&len!==expectedLength)throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);return res}function abstract_utils_concatBytes(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];utils_abytes(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res}const bitMask=n=>(_2n<<BigInt(n-1))-_1n,u8n=data=>new Uint8Array(data),u8fr=arr=>Uint8Array.from(arr);function createHmacDrbg(hashLen,qByteLen,hmacFn){if("number"!=typeof hashLen||hashLen<2)throw new Error("hashLen must be a number");if("number"!=typeof qByteLen||qByteLen<2)throw new Error("qByteLen must be a number");if("function"!=typeof hmacFn)throw new Error("hmacFn must be a function");let v=u8n(hashLen),k=u8n(hashLen),i=0;const reset=()=>{v.fill(1),k.fill(0),i=0},h=(...b)=>hmacFn(k,v,...b),reseed=(seed=u8n())=>{k=h(u8fr([0]),seed),v=h(),0!==seed.length&&(k=h(u8fr([1]),seed),v=h())},gen=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let len=0;const out=[];for(;len<qByteLen;){v=h();const sl=v.slice();out.push(sl),len+=v.length}return abstract_utils_concatBytes(...out)};return(seed,pred)=>{let res;for(reset(),reseed(seed);!(res=pred(gen()));)reseed();return reset(),res}}const validatorFns={bigint:val=>"bigint"==typeof val,function:val=>"function"==typeof val,boolean:val=>"boolean"==typeof val,string:val=>"string"==typeof val,stringOrUint8Array:val=>"string"==typeof val||abstract_utils_isBytes(val),isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>"function"==typeof val&&Number.isSafeInteger(val.outputLen)};function validateObject(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if("function"!=typeof checkVal)throw new Error(`Invalid validator "${type}", expected function`);const val=object[fieldName];if(!(isOptional&&void 0===val||checkVal(val,object)))throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`)};for(const[fieldName,type]of Object.entries(validators))checkField(fieldName,type,!1);for(const[fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,!0);return object}const modular_0n=BigInt(0),modular_1n=BigInt(1),modular_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9),BigInt(16);function modular_mod(a,b){const result=a%b;return result>=modular_0n?result:b+result}function pow(num,power,modulo){if(modulo<=modular_0n||power<modular_0n)throw new Error("Expected power/modulo > 0");if(modulo===modular_1n)return modular_0n;let res=modular_1n;for(;power>modular_0n;)power&modular_1n&&(res=res*num%modulo),num=num*num%modulo,power>>=modular_1n;return res}function modular_pow2(x,power,modulo){let res=x;for(;power-- >modular_0n;)res*=res,res%=modulo;return res}function invert(number,modulo){if(number===modular_0n||modulo<=modular_0n)throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);let a=modular_mod(number,modulo),b=modulo,x=modular_0n,y=modular_1n,u=modular_1n,v=modular_0n;for(;a!==modular_0n;){const q=b/a,r=b%a,m=x-u*q,n=y-v*q;b=a,a=r,x=u,y=v,u=m,v=n}if(b!==modular_1n)throw new Error("invert: does not exist");return modular_mod(x,modulo)}function FpSqrt(P){if(P%_4n===_3n){const p1div4=(P+modular_1n)/_4n;return function sqrt3mod4(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function sqrt5mod8(Fp,n){const n2=Fp.mul(n,modular_2n),v=Fp.pow(n2,c1),nv=Fp.mul(n,v),i=Fp.mul(Fp.mul(nv,modular_2n),v),root=Fp.mul(nv,Fp.sub(i,Fp.ONE));if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}return function tonelliShanks(P){const legendreC=(P-modular_1n)/modular_2n;let Q,S,Z;for(Q=P-modular_1n,S=0;Q%modular_2n===modular_0n;Q/=modular_2n,S++);for(Z=modular_2n;Z<P&&pow(Z,legendreC,P)!==P-modular_1n;Z++);if(1===S){const p1div4=(P+modular_1n)/_4n;return function tonelliFast(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}const Q1div2=(Q+modular_1n)/modular_2n;return function tonelliSlow(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw new Error("Cannot find square root");let r=S,g=Fp.pow(Fp.mul(Fp.ONE,Z),Q),x=Fp.pow(n,Q1div2),b=Fp.pow(n,Q);for(;!Fp.eql(b,Fp.ONE);){if(Fp.eql(b,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(b);m<r&&!Fp.eql(t2,Fp.ONE);m++)t2=Fp.sqr(t2);const ge=Fp.pow(g,modular_1n<<BigInt(r-m-1));g=Fp.sqr(ge),x=Fp.mul(x,ge),b=Fp.mul(b,g),r=m}return x}}(P)}const modular_isNegativeLE=(num,modulo)=>(modular_mod(num,modulo)&modular_1n)===modular_1n,FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(n,nBitLength){const _nBitLength=void 0!==nBitLength?nBitLength:n.toString(2).length;return{nBitLength:_nBitLength,nByteLength:Math.ceil(_nBitLength/8)}}function Field(ORDER,bitLen,isLE=!1,redef={}){if(ORDER<=modular_0n)throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);const{nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(BYTES>2048)throw new Error("Field lengths over 2048 bytes are not supported");const sqrtP=FpSqrt(ORDER),f=Object.freeze({ORDER,BITS,BYTES,MASK:bitMask(BITS),ZERO:modular_0n,ONE:modular_1n,create:num=>modular_mod(num,ORDER),isValid:num=>{if("bigint"!=typeof num)throw new Error("Invalid field element: expected bigint, got "+typeof num);return modular_0n<=num&&num<ORDER},is0:num=>num===modular_0n,isOdd:num=>(num&modular_1n)===modular_1n,neg:num=>modular_mod(-num,ORDER),eql:(lhs,rhs)=>lhs===rhs,sqr:num=>modular_mod(num*num,ORDER),add:(lhs,rhs)=>modular_mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>modular_mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>modular_mod(lhs*rhs,ORDER),pow:(num,power)=>function FpPow(f,num,power){if(power<modular_0n)throw new Error("Expected power > 0");if(power===modular_0n)return f.ONE;if(power===modular_1n)return num;let p=f.ONE,d=num;for(;power>modular_0n;)power&modular_1n&&(p=f.mul(p,d)),d=f.sqr(d),power>>=modular_1n;return p}(f,num,power),div:(lhs,rhs)=>modular_mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>function FpInvertBatch(f,nums){const tmp=new Array(nums.length),lastMultiplied=nums.reduce(((acc,num,i)=>f.is0(num)?acc:(tmp[i]=acc,f.mul(acc,num))),f.ONE),inverted=f.inv(lastMultiplied);return nums.reduceRight(((acc,num,i)=>f.is0(num)?acc:(tmp[i]=f.mul(acc,tmp[i]),f.mul(acc,num))),inverted),tmp}(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?utils_numberToBytesLE(num,BYTES):utils_numberToBytesBE(num,BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?utils_bytesToNumberLE(bytes):utils_bytesToNumberBE(bytes)}});return Object.freeze(f)}function getFieldBytesLength(fieldOrder){if("bigint"!=typeof fieldOrder)throw new Error("field order must be bigint");const bitLength=fieldOrder.toString(2).length;return Math.ceil(bitLength/8)}function getMinHashLength(fieldOrder){const length=getFieldBytesLength(fieldOrder);return length+Math.ceil(length/2)}const curve_0n=BigInt(0),curve_1n=BigInt(1);function wNAF(c,bits){const constTimeNegate=(condition,item)=>{const neg=item.negate();return condition?neg:item},opts=W=>({windows:Math.ceil(bits/W)+1,windowSize:2**(W-1)});return{constTimeNegate,unsafeLadder(elm,n){let p=c.ZERO,d=elm;for(;n>curve_0n;)n&curve_1n&&(p=p.add(d)),d=d.double(),n>>=curve_1n;return p},precomputeWindow(elm,W){const{windows,windowSize}=opts(W),points=[];let p=elm,base=p;for(let window=0;window<windows;window++){base=p,points.push(base);for(let i=1;i<windowSize;i++)base=base.add(p),points.push(base);p=base.double()}return points},wNAF(W,precomputes,n){const{windows,windowSize}=opts(W);let p=c.ZERO,f=c.BASE;const mask=BigInt(2**W-1),maxNumber=2**W,shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy,wbits>windowSize&&(wbits-=maxNumber,n+=curve_1n);const offset1=offset,offset2=offset+Math.abs(wbits)-1,cond1=window%2!=0,cond2=wbits<0;0===wbits?f=f.add(constTimeNegate(cond1,precomputes[offset1])):p=p.add(constTimeNegate(cond2,precomputes[offset2]))}return{p,f}},wNAFCached(P,precomputesMap,n,transform){const W=P._WINDOW_SIZE||1;let comp=precomputesMap.get(P);return comp||(comp=this.precomputeWindow(P,W),1!==W&&precomputesMap.set(P,transform(comp))),this.wNAF(W,comp,n)}}}function validateBasic(curve){return function validateField(field){const opts=FIELD_FIELDS.reduce(((map,val)=>(map[val]="function",map)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return validateObject(field,opts)}(curve.Fp),validateObject(curve,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(curve.n,curve.nBitLength),...curve,p:curve.Fp.ORDER})}const edwards_0n=BigInt(0),edwards_1n=BigInt(1),edwards_2n=BigInt(2),edwards_8n=BigInt(8),VERIFY_DEFAULT={zip215:!0};function twistedEdwards(curveDef){const CURVE=function validateOpts(curve){const opts=validateBasic(curve);return validateObject(curve,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...opts})}(curveDef),{Fp,n:CURVE_ORDER,prehash,hash:cHash,randomBytes,nByteLength,h:cofactor}=CURVE,MASK=edwards_2n<<BigInt(8*nByteLength)-edwards_1n,modP=Fp.create,uvRatio=CURVE.uvRatio||((u,v)=>{try{return{isValid:!0,value:Fp.sqrt(u*Fp.inv(v))}}catch(e){return{isValid:!1,value:edwards_0n}}}),adjustScalarBytes=CURVE.adjustScalarBytes||(bytes=>bytes),domain=CURVE.domain||((data,ctx,phflag)=>{if(ctx.length||phflag)throw new Error("Contexts/pre-hash are not supported");return data}),inBig=n=>"bigint"==typeof n&&edwards_0n<n,inRange=(n,max)=>inBig(n)&&inBig(max)&&n<max,in0MaskRange=n=>n===edwards_0n||inRange(n,MASK);function assertInRange(n,max){if(inRange(n,max))return n;throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`)}function assertGE0(n){return n===edwards_0n?n:assertInRange(n,CURVE_ORDER)}const pointPrecomputes=new Map;function isPoint(other){if(!(other instanceof Point))throw new Error("ExtendedPoint expected")}class Point{constructor(ex,ey,ez,et){if(this.ex=ex,this.ey=ey,this.ez=ez,this.et=et,!in0MaskRange(ex))throw new Error("x required");if(!in0MaskRange(ey))throw new Error("y required");if(!in0MaskRange(ez))throw new Error("z required");if(!in0MaskRange(et))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(p){if(p instanceof Point)throw new Error("extended point not allowed");const{x,y}=p||{};if(!in0MaskRange(x)||!in0MaskRange(y))throw new Error("invalid affine point");return new Point(x,y,edwards_1n,modP(x*y))}static normalizeZ(points){const toInv=Fp.invertBatch(points.map((p=>p.ez)));return points.map(((p,i)=>p.toAffine(toInv[i]))).map(Point.fromAffine)}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize,pointPrecomputes.delete(this)}assertValidity(){const{a,d}=CURVE;if(this.is0())throw new Error("bad point: ZERO");const{ex:X,ey:Y,ez:Z,et:T}=this,X2=modP(X*X),Y2=modP(Y*Y),Z2=modP(Z*Z),Z4=modP(Z2*Z2),aX2=modP(X2*a);if(modP(Z2*modP(aX2+Y2))!==modP(Z4+modP(d*modP(X2*Y2))))throw new Error("bad point: equation left != right (1)");if(modP(X*Y)!==modP(Z*T))throw new Error("bad point: equation left != right (2)")}equals(other){isPoint(other);const{ex:X1,ey:Y1,ez:Z1}=this,{ex:X2,ey:Y2,ez:Z2}=other,X1Z2=modP(X1*Z2),X2Z1=modP(X2*Z1),Y1Z2=modP(Y1*Z2),Y2Z1=modP(Y2*Z1);return X1Z2===X2Z1&&Y1Z2===Y2Z1}is0(){return this.equals(Point.ZERO)}negate(){return new Point(modP(-this.ex),this.ey,this.ez,modP(-this.et))}double(){const{a}=CURVE,{ex:X1,ey:Y1,ez:Z1}=this,A=modP(X1*X1),B=modP(Y1*Y1),C=modP(edwards_2n*modP(Z1*Z1)),D=modP(a*A),x1y1=X1+Y1,E=modP(modP(x1y1*x1y1)-A-B),G=D+B,F=G-C,H=D-B,X3=modP(E*F),Y3=modP(G*H),T3=modP(E*H),Z3=modP(F*G);return new Point(X3,Y3,Z3,T3)}add(other){isPoint(other);const{a,d}=CURVE,{ex:X1,ey:Y1,ez:Z1,et:T1}=this,{ex:X2,ey:Y2,ez:Z2,et:T2}=other;if(a===BigInt(-1)){const A=modP((Y1-X1)*(Y2+X2)),B=modP((Y1+X1)*(Y2-X2)),F=modP(B-A);if(F===edwards_0n)return this.double();const C=modP(Z1*edwards_2n*T2),D=modP(T1*edwards_2n*Z2),E=D+C,G=B+A,H=D-C,X3=modP(E*F),Y3=modP(G*H),T3=modP(E*H),Z3=modP(F*G);return new Point(X3,Y3,Z3,T3)}const A=modP(X1*X2),B=modP(Y1*Y2),C=modP(T1*d*T2),D=modP(Z1*Z2),E=modP((X1+Y1)*(X2+Y2)-A-B),F=D-C,G=D+C,H=modP(B-a*A),X3=modP(E*F),Y3=modP(G*H),T3=modP(E*H),Z3=modP(F*G);return new Point(X3,Y3,Z3,T3)}subtract(other){return this.add(other.negate())}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,Point.normalizeZ)}multiply(scalar){const{p,f}=this.wNAF(assertInRange(scalar,CURVE_ORDER));return Point.normalizeZ([p,f])[0]}multiplyUnsafe(scalar){let n=assertGE0(scalar);return n===edwards_0n?I:this.equals(I)||n===edwards_1n?this:this.equals(G)?this.wNAF(n).p:wnaf.unsafeLadder(this,n)}isSmallOrder(){return this.multiplyUnsafe(cofactor).is0()}isTorsionFree(){return wnaf.unsafeLadder(this,CURVE_ORDER).is0()}toAffine(iz){const{ex:x,ey:y,ez:z}=this,is0=this.is0();null==iz&&(iz=is0?edwards_8n:Fp.inv(z));const ax=modP(x*iz),ay=modP(y*iz),zz=modP(z*iz);if(is0)return{x:edwards_0n,y:edwards_1n};if(zz!==edwards_1n)throw new Error("invZ was invalid");return{x:ax,y:ay}}clearCofactor(){const{h:cofactor}=CURVE;return cofactor===edwards_1n?this:this.multiplyUnsafe(cofactor)}static fromHex(hex,zip215=!1){const{d,a}=CURVE,len=Fp.BYTES,normed=(hex=utils_ensureBytes("pointHex",hex,len)).slice(),lastByte=hex[len-1];normed[len-1]=-129&lastByte;const y=utils_bytesToNumberLE(normed);y===edwards_0n||assertInRange(y,zip215?MASK:Fp.ORDER);const y2=modP(y*y),u=modP(y2-edwards_1n),v=modP(d*y2-a);let{isValid,value:x}=uvRatio(u,v);if(!isValid)throw new Error("Point.fromHex: invalid y coordinate");const isXOdd=(x&edwards_1n)===edwards_1n,isLastByteOdd=0!=(128&lastByte);if(!zip215&&x===edwards_0n&&isLastByteOdd)throw new Error("Point.fromHex: x=0 and x_0=1");return isLastByteOdd!==isXOdd&&(x=modP(-x)),Point.fromAffine({x,y})}static fromPrivateKey(privKey){return getExtendedPublicKey(privKey).point}toRawBytes(){const{x,y}=this.toAffine(),bytes=utils_numberToBytesLE(y,Fp.BYTES);return bytes[bytes.length-1]|=x&edwards_1n?128:0,bytes}toHex(){return abstract_utils_bytesToHex(this.toRawBytes())}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,edwards_1n,modP(CURVE.Gx*CURVE.Gy)),Point.ZERO=new Point(edwards_0n,edwards_1n,edwards_1n,edwards_0n);const{BASE:G,ZERO:I}=Point,wnaf=wNAF(Point,8*nByteLength);function modN(a){return modular_mod(a,CURVE_ORDER)}function modN_LE(hash){return modN(utils_bytesToNumberLE(hash))}function getExtendedPublicKey(key){const len=nByteLength;key=utils_ensureBytes("private key",key,len);const hashed=utils_ensureBytes("hashed private key",cHash(key),2*len),head=adjustScalarBytes(hashed.slice(0,len)),prefix=hashed.slice(len,2*len),scalar=modN_LE(head),point=G.multiply(scalar),pointBytes=point.toRawBytes();return{head,prefix,scalar,point,pointBytes}}function hashDomainToScalar(context=new Uint8Array,...msgs){const msg=abstract_utils_concatBytes(...msgs);return modN_LE(cHash(domain(msg,utils_ensureBytes("context",context),!!prehash)))}const verifyOpts=VERIFY_DEFAULT;G._setWindowSize(8);return{CURVE,getPublicKey:function getPublicKey(privKey){return getExtendedPublicKey(privKey).pointBytes},sign:function sign(msg,privKey,options={}){msg=utils_ensureBytes("message",msg),prehash&&(msg=prehash(msg));const{prefix,scalar,pointBytes}=getExtendedPublicKey(privKey),r=hashDomainToScalar(options.context,prefix,msg),R=G.multiply(r).toRawBytes(),s=modN(r+hashDomainToScalar(options.context,R,pointBytes,msg)*scalar);return assertGE0(s),utils_ensureBytes("result",abstract_utils_concatBytes(R,utils_numberToBytesLE(s,Fp.BYTES)),2*nByteLength)},verify:function verify(sig,msg,publicKey,options=verifyOpts){const{context,zip215}=options,len=Fp.BYTES;sig=utils_ensureBytes("signature",sig,2*len),msg=utils_ensureBytes("message",msg),prehash&&(msg=prehash(msg));const s=utils_bytesToNumberLE(sig.slice(len,2*len));let A,R,SB;try{A=Point.fromHex(publicKey,zip215),R=Point.fromHex(sig.slice(0,len),zip215),SB=G.multiplyUnsafe(s)}catch(error){return!1}if(!zip215&&A.isSmallOrder())return!1;const k=hashDomainToScalar(context,R.toRawBytes(),A.toRawBytes(),msg);return R.add(A.multiplyUnsafe(k)).subtract(SB).clearCofactor().equals(Point.ZERO)},ExtendedPoint:Point,utils:{getExtendedPublicKey,randomPrivateKey:()=>randomBytes(Fp.BYTES),precompute:(windowSize=8,point=Point.BASE)=>(point._setWindowSize(windowSize),point.multiply(BigInt(3)),point)}}}const ED25519_P=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),ED25519_SQRT_M1=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),ed25519_1n=(BigInt(0),BigInt(1)),ed25519_2n=BigInt(2),ed25519_5n=BigInt(5),_10n=BigInt(10),_20n=BigInt(20),_40n=BigInt(40),_80n=BigInt(80);function ed25519_pow_2_252_3(x){const P=ED25519_P,b2=x*x%P*x%P,b4=modular_pow2(b2,ed25519_2n,P)*b2%P,b5=modular_pow2(b4,ed25519_1n,P)*x%P,b10=modular_pow2(b5,ed25519_5n,P)*b5%P,b20=modular_pow2(b10,_10n,P)*b10%P,b40=modular_pow2(b20,_20n,P)*b20%P,b80=modular_pow2(b40,_40n,P)*b40%P,b160=modular_pow2(b80,_80n,P)*b80%P,b240=modular_pow2(b160,_80n,P)*b80%P,b250=modular_pow2(b240,_10n,P)*b10%P;return{pow_p_5_8:modular_pow2(b250,ed25519_2n,P)*x%P,b2}}function adjustScalarBytes(bytes){return bytes[0]&=248,bytes[31]&=127,bytes[31]|=64,bytes}function uvRatio(u,v){const P=ED25519_P,v3=modular_mod(v*v*v,P),v7=modular_mod(v3*v3*v,P);let x=modular_mod(u*v3*ed25519_pow_2_252_3(u*v7).pow_p_5_8,P);const vx2=modular_mod(v*x*x,P),root1=x,root2=modular_mod(x*ED25519_SQRT_M1,P),useRoot1=vx2===u,useRoot2=vx2===modular_mod(-u,P),noRoot=vx2===modular_mod(-u*ED25519_SQRT_M1,P);return useRoot1&&(x=root1),(useRoot2||noRoot)&&(x=root2),modular_isNegativeLE(x,P)&&(x=modular_mod(-x,P)),{isValid:useRoot1||useRoot2,value:x}}const Fp=Field(ED25519_P,void 0,!0),ed25519Defaults={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:sha512_sha512,randomBytes:utils_randomBytes,adjustScalarBytes,uvRatio},ed25519=twistedEdwards(ed25519Defaults);function ed25519_domain(data,ctx,phflag){if(ctx.length>255)throw new Error("Context is too big");return utils_concatBytes(utils_utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([phflag?1:0,ctx.length]),ctx,data)}const ELL2_C1=(Fp.ORDER+BigInt(3))/BigInt(8);Fp.pow(ed25519_2n,ELL2_C1),Fp.sqrt(Fp.neg(Fp.ONE)),Fp.ORDER,BigInt(5),BigInt(8),BigInt(486662);(function FpSqrtEven(Fp,elm){if(!Fp.isOdd)throw new Error("Field doesn't have isOdd");const root=Fp.sqrt(elm);return Fp.isOdd(root)?Fp.neg(root):root})(Fp,Fp.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var bn=__webpack_require__("./node_modules/bn.js/lib/bn.js"),bn_default=__webpack_require__.n(bn),node_modules_bs58=__webpack_require__("./node_modules/@solana/web3.js/node_modules/bs58/index.js"),bs58_default=__webpack_require__.n(node_modules_bs58);const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=rotr(W15,7)^rotr(W15,18)^W15>>>3,s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+(rotr(E,6)^rotr(E,11)^rotr(E,25))+((a=E)&F^~a&G)+SHA256_K[i]+SHA256_W[i]|0,T2=(rotr(A,2)^rotr(A,13)^rotr(A,22))+Maj(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}var a;A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sha256_sha256=utils_wrapConstructor((()=>new SHA256));var lib=__webpack_require__("./node_modules/borsh/lib/index.js"),Layout=__webpack_require__("./node_modules/@solana/buffer-layout/lib/Layout.js"),browser=__webpack_require__("./node_modules/bigint-buffer/dist/browser.js");__webpack_require__("./node_modules/console-browserify/index.js");class StructError extends TypeError{constructor(failure,failures){let cached;const{message,...rest}=failure,{path}=failure;super(0===path.length?message:"At path: "+path.join(".")+" -- "+message),Object.assign(this,rest),this.name=this.constructor.name,this.failures=()=>{var _cached;return null!=(_cached=cached)?_cached:cached=[failure,...failures()]}}}function isObject(x){return"object"==typeof x&&null!=x}function print(value){return"string"==typeof value?JSON.stringify(value):""+value}function toFailure(result,context,struct,value){if(!0===result)return;!1===result?result={}:"string"==typeof result&&(result={message:result});const{path,branch}=context,{type}=struct,{refinement,message="Expected a value of type `"+type+"`"+(refinement?" with refinement `"+refinement+"`":"")+", but received: `"+print(value)+"`"}=result;return{value,type,refinement,key:path[path.length-1],path,branch,...result,message}}function*toFailures(result,context,struct,value){(function isIterable(x){return isObject(x)&&"function"==typeof x[Symbol.iterator]})(result)||(result=[result]);for(const r of result){const failure=toFailure(r,context,struct,value);failure&&(yield failure)}}function*run(value,struct,options={}){const{path=[],branch=[value],coerce=!1,mask=!1}=options,ctx={path,branch};if(coerce&&(value=struct.coercer(value,ctx),mask&&"type"!==struct.type&&isObject(struct.schema)&&isObject(value)&&!Array.isArray(value)))for(const key in value)void 0===struct.schema[key]&&delete value[key];let valid=!0;for(const failure of struct.validator(value,ctx))valid=!1,yield[failure,void 0];for(let[k,v,s]of struct.entries(value,ctx)){const ts=run(v,s,{path:void 0===k?path:[...path,k],branch:void 0===k?branch:[...branch,v],coerce,mask});for(const t of ts)t[0]?(valid=!1,yield[t[0],void 0]):coerce&&(v=t[1],void 0===k?value=v:value instanceof Map?value.set(k,v):value instanceof Set?value.add(v):isObject(value)&&(value[k]=v))}if(valid)for(const failure of struct.refiner(value,ctx))valid=!1,yield[failure,void 0];valid&&(yield[void 0,value])}class Struct{constructor(props){const{type,schema,validator,refiner,coercer=value=>value,entries=function*(){}}=props;this.type=type,this.schema=schema,this.entries=entries,this.coercer=coercer,this.validator=validator?(value,context)=>toFailures(validator(value,context),context,this,value):()=>[],this.refiner=refiner?(value,context)=>toFailures(refiner(value,context),context,this,value):()=>[]}assert(value){return function index_es_assert(value,struct){const result=validate(value,struct);if(result[0])throw result[0]}(value,this)}create(value){return index_es_create(value,this)}is(value){return is(value,this)}mask(value){return function mask(value,struct){const result=validate(value,struct,{coerce:!0,mask:!0});if(result[0])throw result[0];return result[1]}(value,this)}validate(value,options={}){return validate(value,this,options)}}function index_es_create(value,struct){const result=validate(value,struct,{coerce:!0});if(result[0])throw result[0];return result[1]}function is(value,struct){return!validate(value,struct)[0]}function validate(value,struct,options={}){const tuples=run(value,struct,options),tuple=function shiftIterator(input){const{done,value}=input.next();return done?void 0:value}(tuples);if(tuple[0]){return[new StructError(tuple[0],(function*(){for(const t of tuples)t[0]&&(yield t[0])})),void 0]}return[void 0,tuple[1]]}function index_es_define(name,validator){return new Struct({type:name,schema:null,validator})}function index_es_array(Element){return new Struct({type:"array",schema:Element,*entries(value){if(Element&&Array.isArray(value))for(const[i,v]of value.entries())yield[i,v,Element]},coercer:value=>Array.isArray(value)?value.slice():value,validator:value=>Array.isArray(value)||"Expected an array value, but received: "+print(value)})}function index_es_boolean(){return index_es_define("boolean",(value=>"boolean"==typeof value))}function instance(Class){return index_es_define("instance",(value=>value instanceof Class||"Expected a `"+Class.name+"` instance, but received: "+print(value)))}function literal(constant){const description=print(constant),t=typeof constant;return new Struct({type:"literal",schema:"string"===t||"number"===t||"boolean"===t?constant:null,validator:value=>value===constant||"Expected the literal `"+description+"`, but received: "+print(value)})}function never(){return index_es_define("never",(()=>!1))}function index_es_nullable(struct){return new Struct({...struct,validator:(value,ctx)=>null===value||struct.validator(value,ctx),refiner:(value,ctx)=>null===value||struct.refiner(value,ctx)})}function index_es_number(){return index_es_define("number",(value=>"number"==typeof value&&!isNaN(value)||"Expected a number, but received: "+print(value)))}function optional(struct){return new Struct({...struct,validator:(value,ctx)=>void 0===value||struct.validator(value,ctx),refiner:(value,ctx)=>void 0===value||struct.refiner(value,ctx)})}function record(Key,Value){return new Struct({type:"record",schema:null,*entries(value){if(isObject(value))for(const k in value){const v=value[k];yield[k,k,Key],yield[k,v,Value]}},validator:value=>isObject(value)||"Expected an object, but received: "+print(value)})}function index_es_string(){return index_es_define("string",(value=>"string"==typeof value||"Expected a string, but received: "+print(value)))}function tuple(Elements){const Never=never();return new Struct({type:"tuple",schema:null,*entries(value){if(Array.isArray(value)){const length=Math.max(Elements.length,value.length);for(let i=0;i<length;i++)yield[i,value[i],Elements[i]||Never]}},validator:value=>Array.isArray(value)||"Expected an array, but received: "+print(value)})}function type(schema){const keys=Object.keys(schema);return new Struct({type:"type",schema,*entries(value){if(isObject(value))for(const k of keys)yield[k,value[k],schema[k]]},validator:value=>isObject(value)||"Expected an object, but received: "+print(value)})}function union(Structs){const description=Structs.map((s=>s.type)).join(" | ");return new Struct({type:"union",schema:null,validator(value,ctx){const failures=[];for(const S of Structs){const[...tuples]=run(value,S,ctx),[first]=tuples;if(!first[0])return[];for(const[failure]of tuples)failure&&failures.push(failure)}return["Expected the value to satisfy a union of `"+description+"`, but received: "+print(value),...failures]}})}function unknown(){return index_es_define("unknown",(()=>!0))}function coerce(struct,condition,coercer){return new Struct({...struct,coercer:(value,ctx)=>is(value,condition)?struct.coercer(coercer(value,ctx),ctx):struct.coercer(value,ctx)})}__webpack_require__("./node_modules/jayson/lib/client/browser/index.js"),__webpack_require__("./node_modules/rpc-websockets/dist/lib/client.js"),__webpack_require__("./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js");const SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[],sha3_0n=BigInt(0),sha3_1n=BigInt(1),sha3_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let round=0,R=sha3_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=sha3_0n;for(let j=0;j<7;j++)R=(R<<sha3_1n^(R>>_7n)*_0x71n)%_256n,R&sha3_2n&&(t^=sha3_1n<<(sha3_1n<<BigInt(j))-sha3_1n);_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split(_SHA3_IOTA,!0),rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s),rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);class Keccak extends Hash{constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,_assert_number(outputLen),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var arr;this.state=new Uint8Array(200),this.state32=(arr=this.state,new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4)))}keccak(){isLE||byteSwap32(this.state32),function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}B.fill(0)}(this.state32,this.rounds),isLE||byteSwap32(this.state32),this.posOut=0,this.pos=0}update(data){exists(this);const{blockLen,state}=this,len=(data=toBytes(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,0!=(128&suffix)&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){exists(this,!1),bytes(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return _assert_number(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if(output(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}}const gen=(suffix,blockLen,outputLen)=>utils_wrapConstructor((()=>new Keccak(blockLen,suffix,outputLen))),keccak_256=gen(1,136,32);class HMAC extends Hash{constructor(hash,_key){super(),this.finished=!1,this.destroyed=!1,_assert_hash(hash);const key=toBytes(_key);if(this.iHash=hash.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen,pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad),this.oHash=hash.create();for(let i=0;i<pad.length;i++)pad[i]^=106;this.oHash.update(pad),pad.fill(0)}update(buf){return exists(this),this.iHash.update(buf),this}digestInto(out){exists(this),bytes(out,this.outputLen),this.finished=!0,this.iHash.digestInto(out),this.oHash.update(out),this.oHash.digestInto(out),this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);return this.digestInto(out),out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;return to.finished=finished,to.destroyed=destroyed,to.blockLen=blockLen,to.outputLen=outputLen,to.oHash=oHash._cloneInto(to.oHash),to.iHash=iHash._cloneInto(to.iHash),to}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();hmac.create=(hash,key)=>new HMAC(hash,key);const{bytesToNumberBE:b2n,hexToBytes:h2b}=abstract_utils_namespaceObject,DER={Err:class DERErr extends Error{constructor(m=""){super(m)}},_parseInt(data){const{Err:E}=DER;if(data.length<2||2!==data[0])throw new E("Invalid signature integer tag");const len=data[1],res=data.subarray(2,len+2);if(!len||res.length!==len)throw new E("Invalid signature integer: wrong length");if(128&res[0])throw new E("Invalid signature integer: negative");if(0===res[0]&&!(128&res[1]))throw new E("Invalid signature integer: unnecessary leading zero");return{d:b2n(res),l:data.subarray(len+2)}},toSig(hex){const{Err:E}=DER,data="string"==typeof hex?h2b(hex):hex;utils_abytes(data);let l=data.length;if(l<2||48!=data[0])throw new E("Invalid signature tag");if(data[1]!==l-2)throw new E("Invalid signature: incorrect length");const{d:r,l:sBytes}=DER._parseInt(data.subarray(2)),{d:s,l:rBytesLeft}=DER._parseInt(sBytes);if(rBytesLeft.length)throw new E("Invalid signature: left bytes after parsing");return{r,s}},hexFromSig(sig){const slice=s=>8&Number.parseInt(s[0],16)?"00"+s:s,h=num=>{const hex=num.toString(16);return 1&hex.length?`0${hex}`:hex},s=slice(h(sig.s)),r=slice(h(sig.r)),shl=s.length/2,rhl=r.length/2,sl=h(shl),rl=h(rhl);return`30${h(rhl+shl+4)}02${rl}${r}02${sl}${s}`}},weierstrass_0n=BigInt(0),weierstrass_1n=BigInt(1),weierstrass_3n=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(opts){const CURVE=function validatePointOpts(curve){const opts=validateBasic(curve);validateObject(opts,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo,Fp,a}=opts;if(endo){if(!Fp.eql(a,Fp.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof endo||"bigint"!=typeof endo.beta||"function"!=typeof endo.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...opts})}(opts),{Fp}=CURVE,toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{const a=point.toAffine();return abstract_utils_concatBytes(Uint8Array.from([4]),Fp.toBytes(a.x),Fp.toBytes(a.y))}),fromBytes=CURVE.fromBytes||(bytes=>{const tail=bytes.subarray(1);return{x:Fp.fromBytes(tail.subarray(0,Fp.BYTES)),y:Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES))}});function weierstrassEquation(x){const{a,b}=CURVE,x2=Fp.sqr(x),x3=Fp.mul(x2,x);return Fp.add(Fp.add(x3,Fp.mul(x,a)),b)}if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(num){return"bigint"==typeof num&&weierstrass_0n<num&&num<CURVE.n}function assertGE(num){if(!isWithinCurveOrder(num))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(key){const{allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n}=CURVE;if(lengths&&"bigint"!=typeof key){if(abstract_utils_isBytes(key)&&(key=abstract_utils_bytesToHex(key)),"string"!=typeof key||!lengths.includes(key.length))throw new Error("Invalid key");key=key.padStart(2*nByteLength,"0")}let num;try{num="bigint"==typeof key?key:utils_bytesToNumberBE(utils_ensureBytes("private key",key,nByteLength))}catch(error){throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`)}return wrapPrivateKey&&(num=modular_mod(num,n)),assertGE(num),num}const pointPrecomputes=new Map;function assertPrjPoint(other){if(!(other instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(px,py,pz){if(this.px=px,this.py=py,this.pz=pz,null==px||!Fp.isValid(px))throw new Error("x required");if(null==py||!Fp.isValid(py))throw new Error("y required");if(null==pz||!Fp.isValid(pz))throw new Error("z required")}static fromAffine(p){const{x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw new Error("invalid affine point");if(p instanceof Point)throw new Error("projective point not allowed");const is0=i=>Fp.eql(i,Fp.ZERO);return is0(x)&&is0(y)?Point.ZERO:new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map((p=>p.pz)));return points.map(((p,i)=>p.toAffine(toInv[i]))).map(Point.fromAffine)}static fromHex(hex){const P=Point.fromAffine(fromBytes(utils_ensureBytes("pointHex",hex)));return P.assertValidity(),P}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize,pointPrecomputes.delete(this)}assertValidity(){if(this.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(this.py))return;throw new Error("bad point: ZERO")}const{x,y}=this.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw new Error("bad point: x or y not FE");const left=Fp.sqr(y),right=weierstrassEquation(x);if(!Fp.eql(left,right))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(Fp.isOdd)return!Fp.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this,{px:X2,py:Y2,pz:Z2}=other,U1=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1)),U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return U1&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const{a,b}=CURVE,b3=Fp.mul(b,weierstrass_3n),{px:X1,py:Y1,pz:Z1}=this;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO,t0=Fp.mul(X1,X1),t1=Fp.mul(Y1,Y1),t2=Fp.mul(Z1,Z1),t3=Fp.mul(X1,Y1);return t3=Fp.add(t3,t3),Z3=Fp.mul(X1,Z1),Z3=Fp.add(Z3,Z3),X3=Fp.mul(a,Z3),Y3=Fp.mul(b3,t2),Y3=Fp.add(X3,Y3),X3=Fp.sub(t1,Y3),Y3=Fp.add(t1,Y3),Y3=Fp.mul(X3,Y3),X3=Fp.mul(t3,X3),Z3=Fp.mul(b3,Z3),t2=Fp.mul(a,t2),t3=Fp.sub(t0,t2),t3=Fp.mul(a,t3),t3=Fp.add(t3,Z3),Z3=Fp.add(t0,t0),t0=Fp.add(Z3,t0),t0=Fp.add(t0,t2),t0=Fp.mul(t0,t3),Y3=Fp.add(Y3,t0),t2=Fp.mul(Y1,Z1),t2=Fp.add(t2,t2),t0=Fp.mul(t2,t3),X3=Fp.sub(X3,t0),Z3=Fp.mul(t2,t1),Z3=Fp.add(Z3,Z3),Z3=Fp.add(Z3,Z3),new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this,{px:X2,py:Y2,pz:Z2}=other;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;const a=CURVE.a,b3=Fp.mul(CURVE.b,weierstrass_3n);let t0=Fp.mul(X1,X2),t1=Fp.mul(Y1,Y2),t2=Fp.mul(Z1,Z2),t3=Fp.add(X1,Y1),t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4),t4=Fp.add(t0,t1),t3=Fp.sub(t3,t4),t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);return t4=Fp.mul(t4,t5),t5=Fp.add(t0,t2),t4=Fp.sub(t4,t5),t5=Fp.add(Y1,Z1),X3=Fp.add(Y2,Z2),t5=Fp.mul(t5,X3),X3=Fp.add(t1,t2),t5=Fp.sub(t5,X3),Z3=Fp.mul(a,t4),X3=Fp.mul(b3,t2),Z3=Fp.add(X3,Z3),X3=Fp.sub(t1,Z3),Z3=Fp.add(t1,Z3),Y3=Fp.mul(X3,Z3),t1=Fp.add(t0,t0),t1=Fp.add(t1,t0),t2=Fp.mul(a,t2),t4=Fp.mul(b3,t4),t1=Fp.add(t1,t2),t2=Fp.sub(t0,t2),t2=Fp.mul(a,t2),t4=Fp.add(t4,t2),t0=Fp.mul(t1,t4),Y3=Fp.add(Y3,t0),t0=Fp.mul(t5,t4),X3=Fp.mul(t3,X3),X3=Fp.sub(X3,t0),t0=Fp.mul(t3,t1),Z3=Fp.mul(t5,Z3),Z3=Fp.add(Z3,t0),new Point(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,(comp=>{const toInv=Fp.invertBatch(comp.map((p=>p.pz)));return comp.map(((p,i)=>p.toAffine(toInv[i]))).map(Point.fromAffine)}))}multiplyUnsafe(n){const I=Point.ZERO;if(n===weierstrass_0n)return I;if(assertGE(n),n===weierstrass_1n)return this;const{endo}=CURVE;if(!endo)return wnaf.unsafeLadder(this,n);let{k1neg,k1,k2neg,k2}=endo.splitScalar(n),k1p=I,k2p=I,d=this;for(;k1>weierstrass_0n||k2>weierstrass_0n;)k1&weierstrass_1n&&(k1p=k1p.add(d)),k2&weierstrass_1n&&(k2p=k2p.add(d)),d=d.double(),k1>>=weierstrass_1n,k2>>=weierstrass_1n;return k1neg&&(k1p=k1p.negate()),k2neg&&(k2p=k2p.negate()),k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz),k1p.add(k2p)}multiply(scalar){assertGE(scalar);let point,fake,n=scalar;const{endo}=CURVE;if(endo){const{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let{p:k1p,f:f1p}=this.wNAF(k1),{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p),k2p=wnaf.constTimeNegate(k2neg,k2p),k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz),point=k1p.add(k2p),fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(n);point=p,fake=f}return Point.normalizeZ([point,fake])[0]}multiplyAndAddUnsafe(Q,a,b){const G=Point.BASE,mul=(P,a)=>a!==weierstrass_0n&&a!==weierstrass_1n&&P.equals(G)?P.multiply(a):P.multiplyUnsafe(a),sum=mul(this,a).add(mul(Q,b));return sum.is0()?void 0:sum}toAffine(iz){const{px:x,py:y,pz:z}=this,is0=this.is0();null==iz&&(iz=is0?Fp.ONE:Fp.inv(z));const ax=Fp.mul(x,iz),ay=Fp.mul(y,iz),zz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(zz,Fp.ONE))throw new Error("invZ was invalid");return{x:ax,y:ay}}isTorsionFree(){const{h:cofactor,isTorsionFree}=CURVE;if(cofactor===weierstrass_1n)return!0;if(isTorsionFree)return isTorsionFree(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:cofactor,clearCofactor}=CURVE;return cofactor===weierstrass_1n?this:clearCofactor?clearCofactor(Point,this):this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=!0){return this.assertValidity(),toBytes(Point,this,isCompressed)}toHex(isCompressed=!0){return abstract_utils_bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE),Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);const _bits=CURVE.nBitLength,wnaf=wNAF(Point,CURVE.endo?Math.ceil(_bits/2):_bits);return{CURVE,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(curveDef){const CURVE=function weierstrass_validateOpts(curve){const opts=validateBasic(curve);return validateObject(opts,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...opts})}(curveDef),{Fp,n:CURVE_ORDER}=CURVE,compressedLen=Fp.BYTES+1,uncompressedLen=2*Fp.BYTES+1;function modN(a){return modular_mod(a,CURVE_ORDER)}function invN(a){return invert(a,CURVE_ORDER)}const{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){const a=point.toAffine(),x=Fp.toBytes(a.x),cat=abstract_utils_concatBytes;return isCompressed?cat(Uint8Array.from([point.hasEvenY()?2:3]),x):cat(Uint8Array.from([4]),x,Fp.toBytes(a.y))},fromBytes(bytes){const len=bytes.length,head=bytes[0],tail=bytes.subarray(1);if(len!==compressedLen||2!==head&&3!==head){if(len===uncompressedLen&&4===head){return{x:Fp.fromBytes(tail.subarray(0,Fp.BYTES)),y:Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES))}}throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`)}{const x=utils_bytesToNumberBE(tail);if(!function isValidFieldElement(num){return weierstrass_0n<num&&num<Fp.ORDER}(x))throw new Error("Point is not on curve");const y2=weierstrassEquation(x);let y;try{y=Fp.sqrt(y2)}catch(sqrtError){const suffix=sqrtError instanceof Error?": "+sqrtError.message:"";throw new Error("Point is not on curve"+suffix)}return 1==(1&head)!==((y&weierstrass_1n)===weierstrass_1n)&&(y=Fp.neg(y)),{x,y}}}}),numToNByteStr=num=>abstract_utils_bytesToHex(utils_numberToBytesBE(num,CURVE.nByteLength));function isBiggerThanHalfOrder(number){return number>CURVE_ORDER>>weierstrass_1n}const slcNum=(b,from,to)=>utils_bytesToNumberBE(b.slice(from,to));class Signature{constructor(r,s,recovery){this.r=r,this.s=s,this.recovery=recovery,this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;return hex=utils_ensureBytes("compactSignature",hex,2*l),new Signature(slcNum(hex,0,l),slcNum(hex,l,2*l))}static fromDER(hex){const{r,s}=DER.toSig(utils_ensureBytes("DER",hex));return new Signature(r,s)}assertValidity(){if(!isWithinCurveOrder(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!isWithinCurveOrder(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const{r,s,recovery:rec}=this,h=bits2int_modN(utils_ensureBytes("msgHash",msgHash));if(null==rec||![0,1,2,3].includes(rec))throw new Error("recovery id invalid");const radj=2===rec||3===rec?r+CURVE.n:r;if(radj>=Fp.ORDER)throw new Error("recovery id 2 or 3 invalid");const prefix=0==(1&rec)?"02":"03",R=Point.fromHex(prefix+numToNByteStr(radj)),ir=invN(radj),u1=modN(-h*ir),u2=modN(s*ir),Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return utils_hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return utils_hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const utils={isValidPrivateKey(privateKey){try{return normPrivateKeyToScalar(privateKey),!0}catch(error){return!1}},normPrivateKeyToScalar,randomPrivateKey:()=>{const length=getMinHashLength(CURVE.n);return function mapHashToField(key,fieldOrder,isLE=!1){const len=key.length,fieldLen=getFieldBytesLength(fieldOrder),minLen=getMinHashLength(fieldOrder);if(len<16||len<minLen||len>1024)throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);const reduced=modular_mod(isLE?utils_bytesToNumberBE(key):utils_bytesToNumberLE(key),fieldOrder-modular_1n)+modular_1n;return isLE?utils_numberToBytesLE(reduced,fieldLen):utils_numberToBytesBE(reduced,fieldLen)}(CURVE.randomBytes(length),CURVE.n)},precompute:(windowSize=8,point=Point.BASE)=>(point._setWindowSize(windowSize),point.multiply(BigInt(3)),point)};function isProbPub(item){const arr=abstract_utils_isBytes(item),str="string"==typeof item,len=(arr||str)&&item.length;return arr?len===compressedLen||len===uncompressedLen:str?len===2*compressedLen||len===2*uncompressedLen:item instanceof Point}const bits2int=CURVE.bits2int||function(bytes){const num=utils_bytesToNumberBE(bytes),delta=8*bytes.length-CURVE.nBitLength;return delta>0?num>>BigInt(delta):num},bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))},ORDER_MASK=bitMask(CURVE.nBitLength);function int2octets(num){if("bigint"!=typeof num)throw new Error("bigint expected");if(!(weierstrass_0n<=num&&num<ORDER_MASK))throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);return utils_numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if(["recovered","canonical"].some((k=>k in opts)))throw new Error("sign() legacy options not supported");const{hash,randomBytes}=CURVE;let{lowS,prehash,extraEntropy:ent}=opts;null==lowS&&(lowS=!0),msgHash=utils_ensureBytes("msgHash",msgHash),prehash&&(msgHash=utils_ensureBytes("prehashed msgHash",hash(msgHash)));const h1int=bits2int_modN(msgHash),d=normPrivateKeyToScalar(privateKey),seedArgs=[int2octets(d),int2octets(h1int)];if(null!=ent&&!1!==ent){const e=!0===ent?randomBytes(Fp.BYTES):ent;seedArgs.push(utils_ensureBytes("extraEntropy",e))}const seed=abstract_utils_concatBytes(...seedArgs),m=h1int;return{seed,k2sig:function k2sig(kBytes){const k=bits2int(kBytes);if(!isWithinCurveOrder(k))return;const ik=invN(k),q=Point.BASE.multiply(k).toAffine(),r=modN(q.x);if(r===weierstrass_0n)return;const s=modN(ik*modN(m+r*d));if(s===weierstrass_0n)return;let recovery=(q.x===r?0:2)|Number(q.y&weierstrass_1n),normS=s;return lowS&&isBiggerThanHalfOrder(s)&&(normS=function normalizeS(s){return isBiggerThanHalfOrder(s)?modN(-s):s}(s),recovery^=1),new Signature(r,normS,recovery)}}}const defaultSigOpts={lowS:CURVE.lowS,prehash:!1},defaultVerOpts={lowS:CURVE.lowS,prehash:!1};return Point.BASE._setWindowSize(8),{CURVE,getPublicKey:function getPublicKey(privateKey,isCompressed=!0){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)},getSharedSecret:function getSharedSecret(privateA,publicB,isCompressed=!0){if(isProbPub(privateA))throw new Error("first arg must be private key");if(!isProbPub(publicB))throw new Error("second arg must be public key");return Point.fromHex(publicB).multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)},sign:function sign(msgHash,privKey,opts=defaultSigOpts){const{seed,k2sig}=prepSig(msgHash,privKey,opts),C=CURVE;return createHmacDrbg(C.hash.outputLen,C.nByteLength,C.hmac)(seed,k2sig)},verify:function verify(signature,msgHash,publicKey,opts=defaultVerOpts){const sg=signature;if(msgHash=utils_ensureBytes("msgHash",msgHash),publicKey=utils_ensureBytes("publicKey",publicKey),"strict"in opts)throw new Error("options.strict was renamed to lowS");const{lowS,prehash}=opts;let _sig,P;try{if("string"==typeof sg||abstract_utils_isBytes(sg))try{_sig=Signature.fromDER(sg)}catch(derError){if(!(derError instanceof DER.Err))throw derError;_sig=Signature.fromCompact(sg)}else{if("object"!=typeof sg||"bigint"!=typeof sg.r||"bigint"!=typeof sg.s)throw new Error("PARSE");{const{r,s}=sg;_sig=new Signature(r,s)}}P=Point.fromHex(publicKey)}catch(error){if("PARSE"===error.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(lowS&&_sig.hasHighS())return!1;prehash&&(msgHash=CURVE.hash(msgHash));const{r,s}=_sig,h=bits2int_modN(msgHash),is=invN(s),u1=modN(h*is),u2=modN(r*is),R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2)?.toAffine();return!!R&&modN(R.x)===r},ProjectivePoint:Point,Signature,utils}}function getHash(hash){return{hash,hmac:(key,...msgs)=>hmac(hash,key,utils_concatBytes(...msgs)),randomBytes:utils_randomBytes}}const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),secp256k1_1n=BigInt(1),secp256k1_2n=BigInt(2),divNearest=(a,b)=>(a+b/secp256k1_2n)/b;function sqrtMod(y){const P=secp256k1P,_3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22),_23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88),b2=y*y*y%P,b3=b2*b2*y%P,b6=modular_pow2(b3,_3n,P)*b3%P,b9=modular_pow2(b6,_3n,P)*b3%P,b11=modular_pow2(b9,secp256k1_2n,P)*b2%P,b22=modular_pow2(b11,_11n,P)*b11%P,b44=modular_pow2(b22,_22n,P)*b22%P,b88=modular_pow2(b44,_44n,P)*b44%P,b176=modular_pow2(b88,_88n,P)*b88%P,b220=modular_pow2(b176,_44n,P)*b44%P,b223=modular_pow2(b220,_3n,P)*b3%P,t1=modular_pow2(b223,_23n,P)*b22%P,t2=modular_pow2(t1,_6n,P)*b2%P,root=modular_pow2(t2,secp256k1_2n,P);if(!secp256k1_Fp.eql(secp256k1_Fp.sqr(root),y))throw new Error("Cannot find square root");return root}const secp256k1_Fp=Field(secp256k1P,void 0,void 0,{sqrt:sqrtMod}),secp256k1=function createCurve(curveDef,defHash){const create=hash=>weierstrass({...curveDef,...getHash(hash)});return Object.freeze({...create(defHash),create})}({a:BigInt(0),b:BigInt(7),Fp:secp256k1_Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:k=>{const n=secp256k1N,a1=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1=-secp256k1_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2=a1,POW_2_128=BigInt("0x100000000000000000000000000000000"),c1=divNearest(b2*k,n),c2=divNearest(-b1*k,n);let k1=modular_mod(k-c1*a1-c2*a2,n),k2=modular_mod(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128,k2neg=k2>POW_2_128;if(k1neg&&(k1=n-k1),k2neg&&(k2=n-k2),k1>POW_2_128||k2>POW_2_128)throw new Error("splitScalar: Endomorphism failed, k="+k);return{k1neg,k1,k2neg,k2}}}},sha256_sha256);BigInt(0);secp256k1.ProjectivePoint;var index_browser_esm_console=__webpack_require__("./node_modules/console-browserify/index.js");ed25519.utils.randomPrivateKey;const generateKeypair=()=>{const privateScalar=ed25519.utils.randomPrivateKey(),publicKey=getPublicKey(privateScalar),secretKey=new Uint8Array(64);return secretKey.set(privateScalar),secretKey.set(publicKey,32),{publicKey,secretKey}},getPublicKey=ed25519.getPublicKey;function isOnCurve(publicKey){try{return ed25519.ExtendedPoint.fromHex(publicKey),!0}catch{return!1}}const sign=(message,secretKey)=>ed25519.sign(message,secretKey.slice(0,32)),verify=ed25519.verify,toBuffer=arr=>node_modules_buffer.Buffer.isBuffer(arr)?arr:arr instanceof Uint8Array?node_modules_buffer.Buffer.from(arr.buffer,arr.byteOffset,arr.byteLength):node_modules_buffer.Buffer.from(arr);class index_browser_esm_Struct{constructor(properties){Object.assign(this,properties)}encode(){return node_modules_buffer.Buffer.from((0,lib.serialize)(SOLANA_SCHEMA,this))}static decode(data){return(0,lib.deserialize)(SOLANA_SCHEMA,this,data)}static decodeUnchecked(data){return(0,lib.deserializeUnchecked)(SOLANA_SCHEMA,this,data)}}const SOLANA_SCHEMA=new Map;var _class;let _Symbol$toStringTag;let uniquePublicKeyCounter=1;_Symbol$toStringTag=Symbol.toStringTag;class PublicKey extends index_browser_esm_Struct{constructor(value){if(super({}),this._bn=void 0,function isPublicKeyData(value){return void 0!==value._bn}(value))this._bn=value._bn;else{if("string"==typeof value){const decoded=bs58_default().decode(value);if(32!=decoded.length)throw new Error("Invalid public key input");this._bn=new(bn_default())(decoded)}else this._bn=new(bn_default())(value);if(this._bn.byteLength()>32)throw new Error("Invalid public key input")}}static unique(){const key=new PublicKey(uniquePublicKeyCounter);return uniquePublicKeyCounter+=1,new PublicKey(key.toBuffer())}equals(publicKey){return this._bn.eq(publicKey._bn)}toBase58(){return bs58_default().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const buf=this.toBuffer();return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}toBuffer(){const b=this._bn.toArrayLike(node_modules_buffer.Buffer);if(32===b.length)return b;const zeroPad=node_modules_buffer.Buffer.alloc(32);return b.copy(zeroPad,32-b.length),zeroPad}get[_Symbol$toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(fromPublicKey,seed,programId){const buffer=node_modules_buffer.Buffer.concat([fromPublicKey.toBuffer(),node_modules_buffer.Buffer.from(seed),programId.toBuffer()]),publicKeyBytes=sha256_sha256(buffer);return new PublicKey(publicKeyBytes)}static createProgramAddressSync(seeds,programId){let buffer=node_modules_buffer.Buffer.alloc(0);seeds.forEach((function(seed){if(seed.length>32)throw new TypeError("Max seed length exceeded");buffer=node_modules_buffer.Buffer.concat([buffer,toBuffer(seed)])})),buffer=node_modules_buffer.Buffer.concat([buffer,programId.toBuffer(),node_modules_buffer.Buffer.from("ProgramDerivedAddress")]);const publicKeyBytes=sha256_sha256(buffer);if(isOnCurve(publicKeyBytes))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(publicKeyBytes)}static async createProgramAddress(seeds,programId){return this.createProgramAddressSync(seeds,programId)}static findProgramAddressSync(seeds,programId){let address,nonce=255;for(;0!=nonce;){try{const seedsWithNonce=seeds.concat(node_modules_buffer.Buffer.from([nonce]));address=this.createProgramAddressSync(seedsWithNonce,programId)}catch(err){if(err instanceof TypeError)throw err;nonce--;continue}return[address,nonce]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(seeds,programId){return this.findProgramAddressSync(seeds,programId)}static isOnCurve(pubkeyData){return isOnCurve(new PublicKey(pubkeyData).toBytes())}}_class=PublicKey,PublicKey.default=new _class("11111111111111111111111111111111"),SOLANA_SCHEMA.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});new PublicKey("BPFLoader1111111111111111111111111111111111");class TransactionExpiredBlockheightExceededError extends Error{constructor(signature){super(`Signature ${signature} has expired: block height exceeded.`),this.signature=void 0,this.signature=signature}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(signature,timeoutSeconds){super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=signature}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class TransactionExpiredNonceInvalidError extends Error{constructor(signature){super(`Signature ${signature} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=signature}}Object.defineProperty(TransactionExpiredNonceInvalidError.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class MessageAccountKeys{constructor(staticAccountKeys,accountKeysFromLookups){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=staticAccountKeys,this.accountKeysFromLookups=accountKeysFromLookups}keySegments(){const keySegments=[this.staticAccountKeys];return this.accountKeysFromLookups&&(keySegments.push(this.accountKeysFromLookups.writable),keySegments.push(this.accountKeysFromLookups.readonly)),keySegments}get(index){for(const keySegment of this.keySegments()){if(index<keySegment.length)return keySegment[index];index-=keySegment.length}}get length(){return this.keySegments().flat().length}compileInstructions(instructions){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const keyIndexMap=new Map;this.keySegments().flat().forEach(((key,index)=>{keyIndexMap.set(key.toBase58(),index)}));const findKeyIndex=key=>{const keyIndex=keyIndexMap.get(key.toBase58());if(void 0===keyIndex)throw new Error("Encountered an unknown instruction account key during compilation");return keyIndex};return instructions.map((instruction=>({programIdIndex:findKeyIndex(instruction.programId),accountKeyIndexes:instruction.keys.map((meta=>findKeyIndex(meta.pubkey))),data:instruction.data})))}}const publicKey=(property="publicKey")=>Layout.Ik(32,property),signature=(property="signature")=>Layout.Ik(64,property),rustString=(property="string")=>{const rsl=Layout.n_([Layout.Jq("length"),Layout.Jq("lengthPadding"),Layout.Ik(Layout.cv(Layout.Jq(),-8),"chars")],property),_decode=rsl.decode.bind(rsl),_encode=rsl.encode.bind(rsl),rslShim=rsl;return rslShim.decode=(b,offset)=>_decode(b,offset).chars.toString(),rslShim.encode=(str,b,offset)=>{const data={chars:node_modules_buffer.Buffer.from(str,"utf8")};return _encode(data,b,offset)},rslShim.alloc=str=>Layout.Jq().span+Layout.Jq().span+node_modules_buffer.Buffer.from(str,"utf8").length,rslShim};function getAlloc(type,fields){const getItemAlloc=item=>{if(item.span>=0)return item.span;if("function"==typeof item.alloc)return item.alloc(fields[item.property]);if("count"in item&&"elementLayout"in item){const field=fields[item.property];if(Array.isArray(field))return field.length*getItemAlloc(item.elementLayout)}else if("fields"in item)return getAlloc({layout:item},fields[item.property]);return 0};let alloc=0;return type.layout.fields.forEach((item=>{alloc+=getItemAlloc(item)})),alloc}function decodeLength(bytes){let len=0,size=0;for(;;){let elem=bytes.shift();if(len|=(127&elem)<<7*size,size+=1,0==(128&elem))break}return len}function encodeLength(bytes,len){let rem_len=len;for(;;){let elem=127&rem_len;if(rem_len>>=7,0==rem_len){bytes.push(elem);break}elem|=128,bytes.push(elem)}}function index_browser_esm_assert(condition,message){if(!condition)throw new Error(message||"Assertion failed")}class CompiledKeys{constructor(payer,keyMetaMap){this.payer=void 0,this.keyMetaMap=void 0,this.payer=payer,this.keyMetaMap=keyMetaMap}static compile(instructions,payer){const keyMetaMap=new Map,getOrInsertDefault=pubkey=>{const address=pubkey.toBase58();let keyMeta=keyMetaMap.get(address);return void 0===keyMeta&&(keyMeta={isSigner:!1,isWritable:!1,isInvoked:!1},keyMetaMap.set(address,keyMeta)),keyMeta},payerKeyMeta=getOrInsertDefault(payer);payerKeyMeta.isSigner=!0,payerKeyMeta.isWritable=!0;for(const ix of instructions){getOrInsertDefault(ix.programId).isInvoked=!0;for(const accountMeta of ix.keys){const keyMeta=getOrInsertDefault(accountMeta.pubkey);keyMeta.isSigner||=accountMeta.isSigner,keyMeta.isWritable||=accountMeta.isWritable}}return new CompiledKeys(payer,keyMetaMap)}getMessageComponents(){const mapEntries=[...this.keyMetaMap.entries()];index_browser_esm_assert(mapEntries.length<=256,"Max static account keys length exceeded");const writableSigners=mapEntries.filter((([,meta])=>meta.isSigner&&meta.isWritable)),readonlySigners=mapEntries.filter((([,meta])=>meta.isSigner&&!meta.isWritable)),writableNonSigners=mapEntries.filter((([,meta])=>!meta.isSigner&&meta.isWritable)),readonlyNonSigners=mapEntries.filter((([,meta])=>!meta.isSigner&&!meta.isWritable)),header={numRequiredSignatures:writableSigners.length+readonlySigners.length,numReadonlySignedAccounts:readonlySigners.length,numReadonlyUnsignedAccounts:readonlyNonSigners.length};{index_browser_esm_assert(writableSigners.length>0,"Expected at least one writable signer key");const[payerAddress]=writableSigners[0];index_browser_esm_assert(payerAddress===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[header,[...writableSigners.map((([address])=>new PublicKey(address))),...readonlySigners.map((([address])=>new PublicKey(address))),...writableNonSigners.map((([address])=>new PublicKey(address))),...readonlyNonSigners.map((([address])=>new PublicKey(address)))]]}extractTableLookup(lookupTable){const[writableIndexes,drainedWritableKeys]=this.drainKeysFoundInLookupTable(lookupTable.state.addresses,(keyMeta=>!keyMeta.isSigner&&!keyMeta.isInvoked&&keyMeta.isWritable)),[readonlyIndexes,drainedReadonlyKeys]=this.drainKeysFoundInLookupTable(lookupTable.state.addresses,(keyMeta=>!keyMeta.isSigner&&!keyMeta.isInvoked&&!keyMeta.isWritable));if(0!==writableIndexes.length||0!==readonlyIndexes.length)return[{accountKey:lookupTable.key,writableIndexes,readonlyIndexes},{writable:drainedWritableKeys,readonly:drainedReadonlyKeys}]}drainKeysFoundInLookupTable(lookupTableEntries,keyMetaFilter){const lookupTableIndexes=new Array,drainedKeys=new Array;for(const[address,keyMeta]of this.keyMetaMap.entries())if(keyMetaFilter(keyMeta)){const key=new PublicKey(address),lookupTableIndex=lookupTableEntries.findIndex((entry=>entry.equals(key)));lookupTableIndex>=0&&(index_browser_esm_assert(lookupTableIndex<256,"Max lookup table index exceeded"),lookupTableIndexes.push(lookupTableIndex),drainedKeys.push(key),this.keyMetaMap.delete(address))}return[lookupTableIndexes,drainedKeys]}}function guardedShift(byteArray){if(0===byteArray.length)throw new Error("Reached end of buffer unexpectedly");return byteArray.shift()}function guardedSplice(byteArray,...args){const[start]=args;if(2===args.length?start+(args[1]??0)>byteArray.length:start>=byteArray.length)throw new Error("Reached end of buffer unexpectedly");return byteArray.splice(...args)}class Message{constructor(args){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=args.header,this.accountKeys=args.accountKeys.map((account=>new PublicKey(account))),this.recentBlockhash=args.recentBlockhash,this.instructions=args.instructions,this.instructions.forEach((ix=>this.indexToProgramIds.set(ix.programIdIndex,this.accountKeys[ix.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((ix=>({programIdIndex:ix.programIdIndex,accountKeyIndexes:ix.accounts,data:bs58_default().decode(ix.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(args){const compiledKeys=CompiledKeys.compile(args.instructions,args.payerKey),[header,staticAccountKeys]=compiledKeys.getMessageComponents(),instructions=new MessageAccountKeys(staticAccountKeys).compileInstructions(args.instructions).map((ix=>({programIdIndex:ix.programIdIndex,accounts:ix.accountKeyIndexes,data:bs58_default().encode(ix.data)})));return new Message({header,accountKeys:staticAccountKeys,recentBlockhash:args.recentBlockhash,instructions})}isAccountSigner(index){return index<this.header.numRequiredSignatures}isAccountWritable(index){const numSignedAccounts=this.header.numRequiredSignatures;if(index>=this.header.numRequiredSignatures){return index-numSignedAccounts<this.accountKeys.length-numSignedAccounts-this.header.numReadonlyUnsignedAccounts}return index<numSignedAccounts-this.header.numReadonlySignedAccounts}isProgramId(index){return this.indexToProgramIds.has(index)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((_,index)=>!this.isProgramId(index)))}serialize(){const numKeys=this.accountKeys.length;let keyCount=[];encodeLength(keyCount,numKeys);const instructions=this.instructions.map((instruction=>{const{accounts,programIdIndex}=instruction,data=Array.from(bs58_default().decode(instruction.data));let keyIndicesCount=[];encodeLength(keyIndicesCount,accounts.length);let dataCount=[];return encodeLength(dataCount,data.length),{programIdIndex,keyIndicesCount:node_modules_buffer.Buffer.from(keyIndicesCount),keyIndices:accounts,dataLength:node_modules_buffer.Buffer.from(dataCount),data}}));let instructionCount=[];encodeLength(instructionCount,instructions.length);let instructionBuffer=node_modules_buffer.Buffer.alloc(1232);node_modules_buffer.Buffer.from(instructionCount).copy(instructionBuffer);let instructionBufferLength=instructionCount.length;instructions.forEach((instruction=>{const length=Layout.n_([Layout.u8("programIdIndex"),Layout.Ik(instruction.keyIndicesCount.length,"keyIndicesCount"),Layout.A9(Layout.u8("keyIndex"),instruction.keyIndices.length,"keyIndices"),Layout.Ik(instruction.dataLength.length,"dataLength"),Layout.A9(Layout.u8("userdatum"),instruction.data.length,"data")]).encode(instruction,instructionBuffer,instructionBufferLength);instructionBufferLength+=length})),instructionBuffer=instructionBuffer.slice(0,instructionBufferLength);const signDataLayout=Layout.n_([Layout.Ik(1,"numRequiredSignatures"),Layout.Ik(1,"numReadonlySignedAccounts"),Layout.Ik(1,"numReadonlyUnsignedAccounts"),Layout.Ik(keyCount.length,"keyCount"),Layout.A9(publicKey("key"),numKeys,"keys"),publicKey("recentBlockhash")]),transaction={numRequiredSignatures:node_modules_buffer.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:node_modules_buffer.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:node_modules_buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:node_modules_buffer.Buffer.from(keyCount),keys:this.accountKeys.map((key=>toBuffer(key.toBytes()))),recentBlockhash:bs58_default().decode(this.recentBlockhash)};let signData=node_modules_buffer.Buffer.alloc(2048);const length=signDataLayout.encode(transaction,signData);return instructionBuffer.copy(signData,length),signData.slice(0,length+instructionBuffer.length)}static from(buffer){let byteArray=[...buffer];const numRequiredSignatures=guardedShift(byteArray);if(numRequiredSignatures!==(127&numRequiredSignatures))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const numReadonlySignedAccounts=guardedShift(byteArray),numReadonlyUnsignedAccounts=guardedShift(byteArray),accountCount=decodeLength(byteArray);let accountKeys=[];for(let i=0;i<accountCount;i++){const account=guardedSplice(byteArray,0,32);accountKeys.push(new PublicKey(node_modules_buffer.Buffer.from(account)))}const recentBlockhash=guardedSplice(byteArray,0,32),instructionCount=decodeLength(byteArray);let instructions=[];for(let i=0;i<instructionCount;i++){const programIdIndex=guardedShift(byteArray),accounts=guardedSplice(byteArray,0,decodeLength(byteArray)),dataSlice=guardedSplice(byteArray,0,decodeLength(byteArray)),data=bs58_default().encode(node_modules_buffer.Buffer.from(dataSlice));instructions.push({programIdIndex,accounts,data})}const messageArgs={header:{numRequiredSignatures,numReadonlySignedAccounts,numReadonlyUnsignedAccounts},recentBlockhash:bs58_default().encode(node_modules_buffer.Buffer.from(recentBlockhash)),accountKeys,instructions};return new Message(messageArgs)}}class MessageV0{constructor(args){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=args.header,this.staticAccountKeys=args.staticAccountKeys,this.recentBlockhash=args.recentBlockhash,this.compiledInstructions=args.compiledInstructions,this.addressTableLookups=args.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let count=0;for(const lookup of this.addressTableLookups)count+=lookup.readonlyIndexes.length+lookup.writableIndexes.length;return count}getAccountKeys(args){let accountKeysFromLookups;if(args&&"accountKeysFromLookups"in args&&args.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=args.accountKeysFromLookups.writable.length+args.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");accountKeysFromLookups=args.accountKeysFromLookups}else if(args&&"addressLookupTableAccounts"in args&&args.addressLookupTableAccounts)accountKeysFromLookups=this.resolveAddressTableLookups(args.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,accountKeysFromLookups)}isAccountSigner(index){return index<this.header.numRequiredSignatures}isAccountWritable(index){const numSignedAccounts=this.header.numRequiredSignatures,numStaticAccountKeys=this.staticAccountKeys.length;if(index>=numStaticAccountKeys){return index-numStaticAccountKeys<this.addressTableLookups.reduce(((count,lookup)=>count+lookup.writableIndexes.length),0)}if(index>=this.header.numRequiredSignatures){return index-numSignedAccounts<numStaticAccountKeys-numSignedAccounts-this.header.numReadonlyUnsignedAccounts}return index<numSignedAccounts-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(addressLookupTableAccounts){const accountKeysFromLookups={writable:[],readonly:[]};for(const tableLookup of this.addressTableLookups){const tableAccount=addressLookupTableAccounts.find((account=>account.key.equals(tableLookup.accountKey)));if(!tableAccount)throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);for(const index of tableLookup.writableIndexes){if(!(index<tableAccount.state.addresses.length))throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);accountKeysFromLookups.writable.push(tableAccount.state.addresses[index])}for(const index of tableLookup.readonlyIndexes){if(!(index<tableAccount.state.addresses.length))throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index])}}return accountKeysFromLookups}static compile(args){const compiledKeys=CompiledKeys.compile(args.instructions,args.payerKey),addressTableLookups=new Array,accountKeysFromLookups={writable:new Array,readonly:new Array},lookupTableAccounts=args.addressLookupTableAccounts||[];for(const lookupTable of lookupTableAccounts){const extractResult=compiledKeys.extractTableLookup(lookupTable);if(void 0!==extractResult){const[addressTableLookup,{writable,readonly}]=extractResult;addressTableLookups.push(addressTableLookup),accountKeysFromLookups.writable.push(...writable),accountKeysFromLookups.readonly.push(...readonly)}}const[header,staticAccountKeys]=compiledKeys.getMessageComponents(),compiledInstructions=new MessageAccountKeys(staticAccountKeys,accountKeysFromLookups).compileInstructions(args.instructions);return new MessageV0({header,staticAccountKeys,recentBlockhash:args.recentBlockhash,compiledInstructions,addressTableLookups})}serialize(){const encodedStaticAccountKeysLength=Array();encodeLength(encodedStaticAccountKeysLength,this.staticAccountKeys.length);const serializedInstructions=this.serializeInstructions(),encodedInstructionsLength=Array();encodeLength(encodedInstructionsLength,this.compiledInstructions.length);const serializedAddressTableLookups=this.serializeAddressTableLookups(),encodedAddressTableLookupsLength=Array();encodeLength(encodedAddressTableLookupsLength,this.addressTableLookups.length);const messageLayout=Layout.n_([Layout.u8("prefix"),Layout.n_([Layout.u8("numRequiredSignatures"),Layout.u8("numReadonlySignedAccounts"),Layout.u8("numReadonlyUnsignedAccounts")],"header"),Layout.Ik(encodedStaticAccountKeysLength.length,"staticAccountKeysLength"),Layout.A9(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),Layout.Ik(encodedInstructionsLength.length,"instructionsLength"),Layout.Ik(serializedInstructions.length,"serializedInstructions"),Layout.Ik(encodedAddressTableLookupsLength.length,"addressTableLookupsLength"),Layout.Ik(serializedAddressTableLookups.length,"serializedAddressTableLookups")]),serializedMessage=new Uint8Array(1232),serializedMessageLength=messageLayout.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(encodedStaticAccountKeysLength),staticAccountKeys:this.staticAccountKeys.map((key=>key.toBytes())),recentBlockhash:bs58_default().decode(this.recentBlockhash),instructionsLength:new Uint8Array(encodedInstructionsLength),serializedInstructions,addressTableLookupsLength:new Uint8Array(encodedAddressTableLookupsLength),serializedAddressTableLookups},serializedMessage);return serializedMessage.slice(0,serializedMessageLength)}serializeInstructions(){let serializedLength=0;const serializedInstructions=new Uint8Array(1232);for(const instruction of this.compiledInstructions){const encodedAccountKeyIndexesLength=Array();encodeLength(encodedAccountKeyIndexesLength,instruction.accountKeyIndexes.length);const encodedDataLength=Array();encodeLength(encodedDataLength,instruction.data.length);serializedLength+=Layout.n_([Layout.u8("programIdIndex"),Layout.Ik(encodedAccountKeyIndexesLength.length,"encodedAccountKeyIndexesLength"),Layout.A9(Layout.u8(),instruction.accountKeyIndexes.length,"accountKeyIndexes"),Layout.Ik(encodedDataLength.length,"encodedDataLength"),Layout.Ik(instruction.data.length,"data")]).encode({programIdIndex:instruction.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(encodedAccountKeyIndexesLength),accountKeyIndexes:instruction.accountKeyIndexes,encodedDataLength:new Uint8Array(encodedDataLength),data:instruction.data},serializedInstructions,serializedLength)}return serializedInstructions.slice(0,serializedLength)}serializeAddressTableLookups(){let serializedLength=0;const serializedAddressTableLookups=new Uint8Array(1232);for(const lookup of this.addressTableLookups){const encodedWritableIndexesLength=Array();encodeLength(encodedWritableIndexesLength,lookup.writableIndexes.length);const encodedReadonlyIndexesLength=Array();encodeLength(encodedReadonlyIndexesLength,lookup.readonlyIndexes.length);serializedLength+=Layout.n_([publicKey("accountKey"),Layout.Ik(encodedWritableIndexesLength.length,"encodedWritableIndexesLength"),Layout.A9(Layout.u8(),lookup.writableIndexes.length,"writableIndexes"),Layout.Ik(encodedReadonlyIndexesLength.length,"encodedReadonlyIndexesLength"),Layout.A9(Layout.u8(),lookup.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:lookup.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(encodedWritableIndexesLength),writableIndexes:lookup.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(encodedReadonlyIndexesLength),readonlyIndexes:lookup.readonlyIndexes},serializedAddressTableLookups,serializedLength)}return serializedAddressTableLookups.slice(0,serializedLength)}static deserialize(serializedMessage){let byteArray=[...serializedMessage];const prefix=guardedShift(byteArray),maskedPrefix=127&prefix;index_browser_esm_assert(prefix!==maskedPrefix,"Expected versioned message but received legacy message");index_browser_esm_assert(0===maskedPrefix,`Expected versioned message with version 0 but found version ${maskedPrefix}`);const header={numRequiredSignatures:guardedShift(byteArray),numReadonlySignedAccounts:guardedShift(byteArray),numReadonlyUnsignedAccounts:guardedShift(byteArray)},staticAccountKeys=[],staticAccountKeysLength=decodeLength(byteArray);for(let i=0;i<staticAccountKeysLength;i++)staticAccountKeys.push(new PublicKey(guardedSplice(byteArray,0,32)));const recentBlockhash=bs58_default().encode(guardedSplice(byteArray,0,32)),instructionCount=decodeLength(byteArray),compiledInstructions=[];for(let i=0;i<instructionCount;i++){const programIdIndex=guardedShift(byteArray),accountKeyIndexes=guardedSplice(byteArray,0,decodeLength(byteArray)),dataLength=decodeLength(byteArray),data=new Uint8Array(guardedSplice(byteArray,0,dataLength));compiledInstructions.push({programIdIndex,accountKeyIndexes,data})}const addressTableLookupsCount=decodeLength(byteArray),addressTableLookups=[];for(let i=0;i<addressTableLookupsCount;i++){const accountKey=new PublicKey(guardedSplice(byteArray,0,32)),writableIndexes=guardedSplice(byteArray,0,decodeLength(byteArray)),readonlyIndexes=guardedSplice(byteArray,0,decodeLength(byteArray));addressTableLookups.push({accountKey,writableIndexes,readonlyIndexes})}return new MessageV0({header,staticAccountKeys,recentBlockhash,compiledInstructions,addressTableLookups})}}const VersionedMessage={deserializeMessageVersion(serializedMessage){const prefix=serializedMessage[0],maskedPrefix=127&prefix;return maskedPrefix===prefix?"legacy":maskedPrefix},deserialize:serializedMessage=>{const version=VersionedMessage.deserializeMessageVersion(serializedMessage);if("legacy"===version)return Message.from(serializedMessage);if(0===version)return MessageV0.deserialize(serializedMessage);throw new Error(`Transaction message version ${version} deserialization is not supported`)}};const DEFAULT_SIGNATURE=node_modules_buffer.Buffer.alloc(64).fill(0);class TransactionInstruction{constructor(opts){this.keys=void 0,this.programId=void 0,this.data=node_modules_buffer.Buffer.alloc(0),this.programId=opts.programId,this.keys=opts.keys,opts.data&&(this.data=opts.data)}toJSON(){return{keys:this.keys.map((({pubkey,isSigner,isWritable})=>({pubkey:pubkey.toJSON(),isSigner,isWritable}))),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(opts){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,opts)if(opts.feePayer&&(this.feePayer=opts.feePayer),opts.signatures&&(this.signatures=opts.signatures),Object.prototype.hasOwnProperty.call(opts,"nonceInfo")){const{minContextSlot,nonceInfo}=opts;this.minNonceContextSlot=minContextSlot,this.nonceInfo=nonceInfo}else if(Object.prototype.hasOwnProperty.call(opts,"lastValidBlockHeight")){const{blockhash,lastValidBlockHeight}=opts;this.recentBlockhash=blockhash,this.lastValidBlockHeight=lastValidBlockHeight}else{const{recentBlockhash,nonceInfo}=opts;nonceInfo&&(this.nonceInfo=nonceInfo),this.recentBlockhash=recentBlockhash}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((instruction=>instruction.toJSON())),signers:this.signatures.map((({publicKey})=>publicKey.toJSON()))}}add(...items){if(0===items.length)throw new Error("No instructions");return items.forEach((item=>{"instructions"in item?this.instructions=this.instructions.concat(item.instructions):"data"in item&&"programId"in item&&"keys"in item?this.instructions.push(item):this.instructions.push(new TransactionInstruction(item))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let recentBlockhash,instructions,feePayer;if(this.nonceInfo?(recentBlockhash=this.nonceInfo.nonce,instructions=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(recentBlockhash=this.recentBlockhash,instructions=this.instructions),!recentBlockhash)throw new Error("Transaction recentBlockhash required");if(instructions.length<1&&index_browser_esm_console.warn("No instructions provided"),this.feePayer)feePayer=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");feePayer=this.signatures[0].publicKey}for(let i=0;i<instructions.length;i++)if(void 0===instructions[i].programId)throw new Error(`Transaction instruction index ${i} has undefined program id`);const programIds=[],accountMetas=[];instructions.forEach((instruction=>{instruction.keys.forEach((accountMeta=>{accountMetas.push({...accountMeta})}));const programId=instruction.programId.toString();programIds.includes(programId)||programIds.push(programId)})),programIds.forEach((programId=>{accountMetas.push({pubkey:new PublicKey(programId),isSigner:!1,isWritable:!1})}));const uniqueMetas=[];accountMetas.forEach((accountMeta=>{const pubkeyString=accountMeta.pubkey.toString(),uniqueIndex=uniqueMetas.findIndex((x=>x.pubkey.toString()===pubkeyString));uniqueIndex>-1?(uniqueMetas[uniqueIndex].isWritable=uniqueMetas[uniqueIndex].isWritable||accountMeta.isWritable,uniqueMetas[uniqueIndex].isSigner=uniqueMetas[uniqueIndex].isSigner||accountMeta.isSigner):uniqueMetas.push(accountMeta)})),uniqueMetas.sort((function(x,y){if(x.isSigner!==y.isSigner)return x.isSigner?-1:1;if(x.isWritable!==y.isWritable)return x.isWritable?-1:1;return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const feePayerIndex=uniqueMetas.findIndex((x=>x.pubkey.equals(feePayer)));if(feePayerIndex>-1){const[payerMeta]=uniqueMetas.splice(feePayerIndex,1);payerMeta.isSigner=!0,payerMeta.isWritable=!0,uniqueMetas.unshift(payerMeta)}else uniqueMetas.unshift({pubkey:feePayer,isSigner:!0,isWritable:!0});for(const signature of this.signatures){const uniqueIndex=uniqueMetas.findIndex((x=>x.pubkey.equals(signature.publicKey)));if(!(uniqueIndex>-1))throw new Error(`unknown signer: ${signature.publicKey.toString()}`);uniqueMetas[uniqueIndex].isSigner||(uniqueMetas[uniqueIndex].isSigner=!0,index_browser_esm_console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let numRequiredSignatures=0,numReadonlySignedAccounts=0,numReadonlyUnsignedAccounts=0;const signedKeys=[],unsignedKeys=[];uniqueMetas.forEach((({pubkey,isSigner,isWritable})=>{isSigner?(signedKeys.push(pubkey.toString()),numRequiredSignatures+=1,isWritable||(numReadonlySignedAccounts+=1)):(unsignedKeys.push(pubkey.toString()),isWritable||(numReadonlyUnsignedAccounts+=1))}));const accountKeys=signedKeys.concat(unsignedKeys),compiledInstructions=instructions.map((instruction=>{const{data,programId}=instruction;return{programIdIndex:accountKeys.indexOf(programId.toString()),accounts:instruction.keys.map((meta=>accountKeys.indexOf(meta.pubkey.toString()))),data:bs58_default().encode(data)}}));return compiledInstructions.forEach((instruction=>{index_browser_esm_assert(instruction.programIdIndex>=0),instruction.accounts.forEach((keyIndex=>index_browser_esm_assert(keyIndex>=0)))})),new Message({header:{numRequiredSignatures,numReadonlySignedAccounts,numReadonlyUnsignedAccounts},accountKeys,recentBlockhash,instructions:compiledInstructions})}_compile(){const message=this.compileMessage(),signedKeys=message.accountKeys.slice(0,message.header.numRequiredSignatures);if(this.signatures.length===signedKeys.length){if(this.signatures.every(((pair,index)=>signedKeys[index].equals(pair.publicKey))))return message}return this.signatures=signedKeys.map((publicKey=>({signature:null,publicKey}))),message}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(connection){return(await connection.getFeeForMessage(this.compileMessage())).value}setSigners(...signers){if(0===signers.length)throw new Error("No signers");const seen=new Set;this.signatures=signers.filter((publicKey=>{const key=publicKey.toString();return!seen.has(key)&&(seen.add(key),!0)})).map((publicKey=>({signature:null,publicKey})))}sign(...signers){if(0===signers.length)throw new Error("No signers");const seen=new Set,uniqueSigners=[];for(const signer of signers){const key=signer.publicKey.toString();seen.has(key)||(seen.add(key),uniqueSigners.push(signer))}this.signatures=uniqueSigners.map((signer=>({signature:null,publicKey:signer.publicKey})));const message=this._compile();this._partialSign(message,...uniqueSigners)}partialSign(...signers){if(0===signers.length)throw new Error("No signers");const seen=new Set,uniqueSigners=[];for(const signer of signers){const key=signer.publicKey.toString();seen.has(key)||(seen.add(key),uniqueSigners.push(signer))}const message=this._compile();this._partialSign(message,...uniqueSigners)}_partialSign(message,...signers){const signData=message.serialize();signers.forEach((signer=>{const signature=sign(signData,signer.secretKey);this._addSignature(signer.publicKey,toBuffer(signature))}))}addSignature(pubkey,signature){this._compile(),this._addSignature(pubkey,signature)}_addSignature(pubkey,signature){index_browser_esm_assert(64===signature.length);const index=this.signatures.findIndex((sigpair=>pubkey.equals(sigpair.publicKey)));if(index<0)throw new Error(`unknown signer: ${pubkey.toString()}`);this.signatures[index].signature=node_modules_buffer.Buffer.from(signature)}verifySignatures(requireAllSignatures=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),requireAllSignatures)}_getMessageSignednessErrors(message,requireAllSignatures){const errors={};for(const{signature,publicKey}of this.signatures)null===signature?requireAllSignatures&&(errors.missing||=[]).push(publicKey):verify(signature,message,publicKey.toBytes())||(errors.invalid||=[]).push(publicKey);return errors.invalid||errors.missing?errors:void 0}serialize(config){const{requireAllSignatures,verifySignatures}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},config),signData=this.serializeMessage();if(verifySignatures){const sigErrors=this._getMessageSignednessErrors(signData,requireAllSignatures);if(sigErrors){let errorMessage="Signature verification failed.";throw sigErrors.invalid&&(errorMessage+=`\nInvalid signature for public key${1===sigErrors.invalid.length?"":"(s)"} [\`${sigErrors.invalid.map((p=>p.toBase58())).join("`, `")}\`].`),sigErrors.missing&&(errorMessage+=`\nMissing signature for public key${1===sigErrors.missing.length?"":"(s)"} [\`${sigErrors.missing.map((p=>p.toBase58())).join("`, `")}\`].`),new Error(errorMessage)}}return this._serialize(signData)}_serialize(signData){const{signatures}=this,signatureCount=[];encodeLength(signatureCount,signatures.length);const transactionLength=signatureCount.length+64*signatures.length+signData.length,wireTransaction=node_modules_buffer.Buffer.alloc(transactionLength);return index_browser_esm_assert(signatures.length<256),node_modules_buffer.Buffer.from(signatureCount).copy(wireTransaction,0),signatures.forEach((({signature},index)=>{null!==signature&&(index_browser_esm_assert(64===signature.length,"signature has invalid length"),node_modules_buffer.Buffer.from(signature).copy(wireTransaction,signatureCount.length+64*index))})),signData.copy(wireTransaction,signatureCount.length+64*signatures.length),index_browser_esm_assert(wireTransaction.length<=1232,`Transaction too large: ${wireTransaction.length} > 1232`),wireTransaction}get keys(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].keys.map((keyObj=>keyObj.pubkey))}get programId(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].programId}get data(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].data}static from(buffer){let byteArray=[...buffer];const signatureCount=decodeLength(byteArray);let signatures=[];for(let i=0;i<signatureCount;i++){const signature=guardedSplice(byteArray,0,64);signatures.push(bs58_default().encode(node_modules_buffer.Buffer.from(signature)))}return Transaction.populate(Message.from(byteArray),signatures)}static populate(message,signatures=[]){const transaction=new Transaction;return transaction.recentBlockhash=message.recentBlockhash,message.header.numRequiredSignatures>0&&(transaction.feePayer=message.accountKeys[0]),signatures.forEach(((signature,index)=>{const sigPubkeyPair={signature:signature==bs58_default().encode(DEFAULT_SIGNATURE)?null:bs58_default().decode(signature),publicKey:message.accountKeys[index]};transaction.signatures.push(sigPubkeyPair)})),message.instructions.forEach((instruction=>{const keys=instruction.accounts.map((account=>{const pubkey=message.accountKeys[account];return{pubkey,isSigner:transaction.signatures.some((keyObj=>keyObj.publicKey.toString()===pubkey.toString()))||message.isAccountSigner(account),isWritable:message.isAccountWritable(account)}}));transaction.instructions.push(new TransactionInstruction({keys,programId:message.accountKeys[instruction.programIdIndex],data:bs58_default().decode(instruction.data)}))})),transaction._message=message,transaction._json=transaction.toJSON(),transaction}}class VersionedTransaction{get version(){return this.message.version}constructor(message,signatures){if(this.signatures=void 0,this.message=void 0,void 0!==signatures)index_browser_esm_assert(signatures.length===message.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=signatures;else{const defaultSignatures=[];for(let i=0;i<message.header.numRequiredSignatures;i++)defaultSignatures.push(new Uint8Array(64));this.signatures=defaultSignatures}this.message=message}serialize(){const serializedMessage=this.message.serialize(),encodedSignaturesLength=Array();encodeLength(encodedSignaturesLength,this.signatures.length);const transactionLayout=Layout.n_([Layout.Ik(encodedSignaturesLength.length,"encodedSignaturesLength"),Layout.A9(signature(),this.signatures.length,"signatures"),Layout.Ik(serializedMessage.length,"serializedMessage")]),serializedTransaction=new Uint8Array(2048),serializedTransactionLength=transactionLayout.encode({encodedSignaturesLength:new Uint8Array(encodedSignaturesLength),signatures:this.signatures,serializedMessage},serializedTransaction);return serializedTransaction.slice(0,serializedTransactionLength)}static deserialize(serializedTransaction){let byteArray=[...serializedTransaction];const signatures=[],signaturesLength=decodeLength(byteArray);for(let i=0;i<signaturesLength;i++)signatures.push(new Uint8Array(guardedSplice(byteArray,0,64)));const message=VersionedMessage.deserialize(new Uint8Array(byteArray));return new VersionedTransaction(message,signatures)}sign(signers){const messageData=this.message.serialize(),signerPubkeys=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const signer of signers){const signerIndex=signerPubkeys.findIndex((pubkey=>pubkey.equals(signer.publicKey)));index_browser_esm_assert(signerIndex>=0,`Cannot sign with non signer key ${signer.publicKey.toBase58()}`),this.signatures[signerIndex]=sign(messageData,signer.secretKey)}}addSignature(publicKey,signature){index_browser_esm_assert(64===signature.byteLength,"Signature must be 64 bytes long");const signerIndex=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((pubkey=>pubkey.equals(publicKey)));index_browser_esm_assert(signerIndex>=0,`Can not add signature; \`${publicKey.toBase58()}\` is not required to sign this transaction`),this.signatures[signerIndex]=signature}}const SYSVAR_CLOCK_PUBKEY=new PublicKey("SysvarC1ock11111111111111111111111111111111"),SYSVAR_RECENT_BLOCKHASHES_PUBKEY=(new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),new PublicKey("Sysvar1nstructions1111111111111111111111111"),new PublicKey("SysvarRecentB1ockHashes11111111111111111111")),SYSVAR_RENT_PUBKEY=new PublicKey("SysvarRent111111111111111111111111111111111"),SYSVAR_STAKE_HISTORY_PUBKEY=(new PublicKey("SysvarRewards111111111111111111111111111111"),new PublicKey("SysvarS1otHashes111111111111111111111111111"),new PublicKey("SysvarS1otHistory11111111111111111111111111"),new PublicKey("SysvarStakeHistory1111111111111111111111111"));async function sendAndConfirmTransaction(connection,transaction,signers,options){const sendOptions=options&&{skipPreflight:options.skipPreflight,preflightCommitment:options.preflightCommitment||options.commitment,maxRetries:options.maxRetries,minContextSlot:options.minContextSlot},signature=await connection.sendTransaction(transaction,signers,sendOptions);let status;if(null!=transaction.recentBlockhash&&null!=transaction.lastValidBlockHeight)status=(await connection.confirmTransaction({abortSignal:options?.abortSignal,signature,blockhash:transaction.recentBlockhash,lastValidBlockHeight:transaction.lastValidBlockHeight},options&&options.commitment)).value;else if(null!=transaction.minNonceContextSlot&&null!=transaction.nonceInfo){const{nonceInstruction}=transaction.nonceInfo,nonceAccountPubkey=nonceInstruction.keys[0].pubkey;status=(await connection.confirmTransaction({abortSignal:options?.abortSignal,minContextSlot:transaction.minNonceContextSlot,nonceAccountPubkey,nonceValue:transaction.nonceInfo.nonce,signature},options&&options.commitment)).value}else null!=options?.abortSignal&&index_browser_esm_console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),status=(await connection.confirmTransaction(signature,options&&options.commitment)).value;if(status.err)throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);return signature}function sleep(ms){return new Promise((resolve=>setTimeout(resolve,ms)))}function encodeData(type,fields){const allocLength=type.layout.span>=0?type.layout.span:getAlloc(type,fields),data=node_modules_buffer.Buffer.alloc(allocLength),layoutFields=Object.assign({instruction:type.index},fields);return type.layout.encode(layoutFields,data),data}const FeeCalculatorLayout=Layout._O("lamportsPerSignature"),NonceAccountLayout=Layout.n_([Layout.Jq("version"),Layout.Jq("state"),publicKey("authorizedPubkey"),publicKey("nonce"),Layout.n_([FeeCalculatorLayout],"feeCalculator")]),NONCE_ACCOUNT_LENGTH=NonceAccountLayout.span;const index_browser_esm_u64=(length=8,property=>{const layout=(0,Layout.Ik)(length,property),{encode,decode}=(layout=>({decode:layout.decode.bind(layout),encode:layout.encode.bind(layout)}))(layout),bigIntLayout=layout;return bigIntLayout.decode=(buffer,offset)=>{const src=decode(buffer,offset);return(0,browser.oU)(node_modules_buffer.Buffer.from(src))},bigIntLayout.encode=(bigInt,buffer,offset)=>{const src=(0,browser.k$)(bigInt,length);return encode(src,buffer,offset)},bigIntLayout});var length;const SYSTEM_INSTRUCTION_LAYOUTS=Object.freeze({Create:{index:0,layout:Layout.n_([Layout.Jq("instruction"),Layout.gM("lamports"),Layout.gM("space"),publicKey("programId")])},Assign:{index:1,layout:Layout.n_([Layout.Jq("instruction"),publicKey("programId")])},Transfer:{index:2,layout:Layout.n_([Layout.Jq("instruction"),index_browser_esm_u64("lamports")])},CreateWithSeed:{index:3,layout:Layout.n_([Layout.Jq("instruction"),publicKey("base"),rustString("seed"),Layout.gM("lamports"),Layout.gM("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:Layout.n_([Layout.Jq("instruction")])},WithdrawNonceAccount:{index:5,layout:Layout.n_([Layout.Jq("instruction"),Layout.gM("lamports")])},InitializeNonceAccount:{index:6,layout:Layout.n_([Layout.Jq("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:Layout.n_([Layout.Jq("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:Layout.n_([Layout.Jq("instruction"),Layout.gM("space")])},AllocateWithSeed:{index:9,layout:Layout.n_([Layout.Jq("instruction"),publicKey("base"),rustString("seed"),Layout.gM("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:Layout.n_([Layout.Jq("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:Layout.n_([Layout.Jq("instruction"),index_browser_esm_u64("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:Layout.n_([Layout.Jq("instruction")])}});class SystemProgram{constructor(){}static createAccount(params){const data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.Create,{lamports:params.lamports,space:params.space,programId:toBuffer(params.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:params.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:params.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data})}static transfer(params){let data,keys;if("basePubkey"in params){data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed,{lamports:BigInt(params.lamports),seed:params.seed,programId:toBuffer(params.programId.toBuffer())}),keys=[{pubkey:params.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:params.basePubkey,isSigner:!0,isWritable:!1},{pubkey:params.toPubkey,isSigner:!1,isWritable:!0}]}else{data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.Transfer,{lamports:BigInt(params.lamports)}),keys=[{pubkey:params.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:params.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys,programId:this.programId,data})}static assign(params){let data,keys;if("basePubkey"in params){data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed,{base:toBuffer(params.basePubkey.toBuffer()),seed:params.seed,programId:toBuffer(params.programId.toBuffer())}),keys=[{pubkey:params.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:params.basePubkey,isSigner:!0,isWritable:!1}]}else{data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.Assign,{programId:toBuffer(params.programId.toBuffer())}),keys=[{pubkey:params.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys,programId:this.programId,data})}static createAccountWithSeed(params){const data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,{base:toBuffer(params.basePubkey.toBuffer()),seed:params.seed,lamports:params.lamports,space:params.space,programId:toBuffer(params.programId.toBuffer())});let keys=[{pubkey:params.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:params.newAccountPubkey,isSigner:!1,isWritable:!0}];return params.basePubkey!=params.fromPubkey&&keys.push({pubkey:params.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys,programId:this.programId,data})}static createNonceAccount(params){const transaction=new Transaction;"basePubkey"in params&&"seed"in params?transaction.add(SystemProgram.createAccountWithSeed({fromPubkey:params.fromPubkey,newAccountPubkey:params.noncePubkey,basePubkey:params.basePubkey,seed:params.seed,lamports:params.lamports,space:NONCE_ACCOUNT_LENGTH,programId:this.programId})):transaction.add(SystemProgram.createAccount({fromPubkey:params.fromPubkey,newAccountPubkey:params.noncePubkey,lamports:params.lamports,space:NONCE_ACCOUNT_LENGTH,programId:this.programId}));const initParams={noncePubkey:params.noncePubkey,authorizedPubkey:params.authorizedPubkey};return transaction.add(this.nonceInitialize(initParams)),transaction}static nonceInitialize(params){const data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,{authorized:toBuffer(params.authorizedPubkey.toBuffer())}),instructionData={keys:[{pubkey:params.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:this.programId,data};return new TransactionInstruction(instructionData)}static nonceAdvance(params){const data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount),instructionData={keys:[{pubkey:params.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:params.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data};return new TransactionInstruction(instructionData)}static nonceWithdraw(params){const data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,{lamports:params.lamports});return new TransactionInstruction({keys:[{pubkey:params.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:params.toPubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:params.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data})}static nonceAuthorize(params){const data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,{authorized:toBuffer(params.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:params.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:params.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data})}static allocate(params){let data,keys;if("basePubkey"in params){data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed,{base:toBuffer(params.basePubkey.toBuffer()),seed:params.seed,space:params.space,programId:toBuffer(params.programId.toBuffer())}),keys=[{pubkey:params.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:params.basePubkey,isSigner:!0,isWritable:!1}]}else{data=encodeData(SYSTEM_INSTRUCTION_LAYOUTS.Allocate,{space:params.space}),keys=[{pubkey:params.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys,programId:this.programId,data})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");class Loader{constructor(){}static getMinNumSignatures(dataLength){return 2*(Math.ceil(dataLength/Loader.chunkSize)+1+1)}static async load(connection,payer,program,programId,data){{const balanceNeeded=await connection.getMinimumBalanceForRentExemption(data.length),programInfo=await connection.getAccountInfo(program.publicKey,"confirmed");let transaction=null;if(null!==programInfo){if(programInfo.executable)return index_browser_esm_console.error("Program load failed, account is already executable"),!1;programInfo.data.length!==data.length&&(transaction=transaction||new Transaction,transaction.add(SystemProgram.allocate({accountPubkey:program.publicKey,space:data.length}))),programInfo.owner.equals(programId)||(transaction=transaction||new Transaction,transaction.add(SystemProgram.assign({accountPubkey:program.publicKey,programId}))),programInfo.lamports<balanceNeeded&&(transaction=transaction||new Transaction,transaction.add(SystemProgram.transfer({fromPubkey:payer.publicKey,toPubkey:program.publicKey,lamports:balanceNeeded-programInfo.lamports})))}else transaction=(new Transaction).add(SystemProgram.createAccount({fromPubkey:payer.publicKey,newAccountPubkey:program.publicKey,lamports:balanceNeeded>0?balanceNeeded:1,space:data.length,programId}));null!==transaction&&await sendAndConfirmTransaction(connection,transaction,[payer,program],{commitment:"confirmed"})}const dataLayout=Layout.n_([Layout.Jq("instruction"),Layout.Jq("offset"),Layout.Jq("bytesLength"),Layout.Jq("bytesLengthPadding"),Layout.A9(Layout.u8("byte"),Layout.cv(Layout.Jq(),-8),"bytes")]),chunkSize=Loader.chunkSize;let offset=0,array=data,transactions=[];for(;array.length>0;){const bytes=array.slice(0,chunkSize),data=node_modules_buffer.Buffer.alloc(chunkSize+16);dataLayout.encode({instruction:0,offset,bytes,bytesLength:0,bytesLengthPadding:0},data);const transaction=(new Transaction).add({keys:[{pubkey:program.publicKey,isSigner:!0,isWritable:!0}],programId,data});if(transactions.push(sendAndConfirmTransaction(connection,transaction,[payer,program],{commitment:"confirmed"})),connection._rpcEndpoint.includes("solana.com")){const REQUESTS_PER_SECOND=4;await sleep(1e3/REQUESTS_PER_SECOND)}offset+=chunkSize,array=array.slice(chunkSize)}await Promise.all(transactions);{const dataLayout=Layout.n_([Layout.Jq("instruction")]),data=node_modules_buffer.Buffer.alloc(dataLayout.span);dataLayout.encode({instruction:1},data);const transaction=(new Transaction).add({keys:[{pubkey:program.publicKey,isSigner:!0,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId,data}),deployCommitment="processed",finalizeSignature=await connection.sendTransaction(transaction,[payer,program],{preflightCommitment:deployCommitment}),{context,value}=await connection.confirmTransaction({signature:finalizeSignature,lastValidBlockHeight:transaction.lastValidBlockHeight,blockhash:transaction.recentBlockhash},deployCommitment);if(value.err)throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);for(;;){try{if(await connection.getSlot({commitment:deployCommitment})>context.slot)break}catch{}await new Promise((resolve=>setTimeout(resolve,Math.round(200))))}}return!0}}Loader.chunkSize=932;new PublicKey("BPFLoader2111111111111111111111111111111111");Object.prototype.toString,Object.keys;globalThis.fetch;Layout.n_([Layout.Jq("typeIndex"),index_browser_esm_u64("deactivationSlot"),Layout._O("lastExtendedSlot"),Layout.u8("lastExtendedStartIndex"),Layout.u8(),Layout.A9(publicKey(),Layout.cv(Layout.u8(),-1),"authority")]);const PublicKeyFromString=coerce(instance(PublicKey),index_es_string(),(value=>new PublicKey(value))),RawAccountDataResult=tuple([index_es_string(),literal("base64")]),BufferFromRawAccountData=coerce(instance(node_modules_buffer.Buffer),RawAccountDataResult,(value=>node_modules_buffer.Buffer.from(value[0],"base64")));function createRpcResult(result){return union([type({jsonrpc:literal("2.0"),id:index_es_string(),result}),type({jsonrpc:literal("2.0"),id:index_es_string(),error:type({code:unknown(),message:index_es_string(),data:optional(index_es_define("any",(()=>!0)))})})])}const UnknownRpcResult=createRpcResult(unknown());function jsonRpcResult(schema){return coerce(createRpcResult(schema),UnknownRpcResult,(value=>"error"in value?value:{...value,result:index_es_create(value.result,schema)}))}function jsonRpcResultAndContext(value){return jsonRpcResult(type({context:type({slot:index_es_number()}),value}))}function notificationResultAndContext(value){return type({context:type({slot:index_es_number()}),value})}const GetInflationGovernorResult=type({foundation:index_es_number(),foundationTerm:index_es_number(),initial:index_es_number(),taper:index_es_number(),terminal:index_es_number()}),GetRecentPrioritizationFeesResult=(jsonRpcResult(index_es_array(index_es_nullable(type({epoch:index_es_number(),effectiveSlot:index_es_number(),amount:index_es_number(),postBalance:index_es_number(),commission:optional(index_es_nullable(index_es_number()))})))),index_es_array(type({slot:index_es_number(),prioritizationFee:index_es_number()}))),GetInflationRateResult=type({total:index_es_number(),validator:index_es_number(),foundation:index_es_number(),epoch:index_es_number()}),GetEpochInfoResult=type({epoch:index_es_number(),slotIndex:index_es_number(),slotsInEpoch:index_es_number(),absoluteSlot:index_es_number(),blockHeight:optional(index_es_number()),transactionCount:optional(index_es_number())}),GetEpochScheduleResult=type({slotsPerEpoch:index_es_number(),leaderScheduleSlotOffset:index_es_number(),warmup:index_es_boolean(),firstNormalEpoch:index_es_number(),firstNormalSlot:index_es_number()}),GetLeaderScheduleResult=record(index_es_string(),index_es_array(index_es_number())),TransactionErrorResult=index_es_nullable(union([type({}),index_es_string()])),SignatureStatusResult=type({err:TransactionErrorResult}),SignatureReceivedResult=literal("receivedSignature");type({"solana-core":index_es_string(),"feature-set":optional(index_es_number())}),jsonRpcResultAndContext(type({err:index_es_nullable(union([type({}),index_es_string()])),logs:index_es_nullable(index_es_array(index_es_string())),accounts:optional(index_es_nullable(index_es_array(index_es_nullable(type({executable:index_es_boolean(),owner:index_es_string(),lamports:index_es_number(),data:index_es_array(index_es_string()),rentEpoch:optional(index_es_number())}))))),unitsConsumed:optional(index_es_number()),returnData:optional(index_es_nullable(type({programId:index_es_string(),data:tuple([index_es_string(),literal("base64")])})))})),jsonRpcResultAndContext(type({byIdentity:record(index_es_string(),index_es_array(index_es_number())),range:type({firstSlot:index_es_number(),lastSlot:index_es_number()})}));jsonRpcResult(GetInflationGovernorResult),jsonRpcResult(GetInflationRateResult),jsonRpcResult(GetRecentPrioritizationFeesResult),jsonRpcResult(GetEpochInfoResult),jsonRpcResult(GetEpochScheduleResult),jsonRpcResult(GetLeaderScheduleResult),jsonRpcResult(index_es_number()),jsonRpcResultAndContext(type({total:index_es_number(),circulating:index_es_number(),nonCirculating:index_es_number(),nonCirculatingAccounts:index_es_array(PublicKeyFromString)}));const TokenAmountResult=type({amount:index_es_string(),uiAmount:index_es_nullable(index_es_number()),decimals:index_es_number(),uiAmountString:optional(index_es_string())}),ParsedAccountDataResult=(jsonRpcResultAndContext(index_es_array(type({address:PublicKeyFromString,amount:index_es_string(),uiAmount:index_es_nullable(index_es_number()),decimals:index_es_number(),uiAmountString:optional(index_es_string())}))),jsonRpcResultAndContext(index_es_array(type({pubkey:PublicKeyFromString,account:type({executable:index_es_boolean(),owner:PublicKeyFromString,lamports:index_es_number(),data:BufferFromRawAccountData,rentEpoch:index_es_number()})}))),type({program:index_es_string(),parsed:unknown(),space:index_es_number()})),AccountInfoResult=(jsonRpcResultAndContext(index_es_array(type({pubkey:PublicKeyFromString,account:type({executable:index_es_boolean(),owner:PublicKeyFromString,lamports:index_es_number(),data:ParsedAccountDataResult,rentEpoch:index_es_number()})}))),jsonRpcResultAndContext(index_es_array(type({lamports:index_es_number(),address:PublicKeyFromString}))),type({executable:index_es_boolean(),owner:PublicKeyFromString,lamports:index_es_number(),data:BufferFromRawAccountData,rentEpoch:index_es_number()})),ParsedOrRawAccountData=(type({pubkey:PublicKeyFromString,account:AccountInfoResult}),coerce(union([instance(node_modules_buffer.Buffer),ParsedAccountDataResult]),union([RawAccountDataResult,ParsedAccountDataResult]),(value=>Array.isArray(value)?index_es_create(value,BufferFromRawAccountData):value))),ParsedAccountInfoResult=type({executable:index_es_boolean(),owner:PublicKeyFromString,lamports:index_es_number(),data:ParsedOrRawAccountData,rentEpoch:index_es_number()}),ProgramAccountInfoResult=(type({pubkey:PublicKeyFromString,account:ParsedAccountInfoResult}),type({state:union([literal("active"),literal("inactive"),literal("activating"),literal("deactivating")]),active:index_es_number(),inactive:index_es_number()}),jsonRpcResult(index_es_array(type({signature:index_es_string(),slot:index_es_number(),err:TransactionErrorResult,memo:index_es_nullable(index_es_string()),blockTime:optional(index_es_nullable(index_es_number()))}))),jsonRpcResult(index_es_array(type({signature:index_es_string(),slot:index_es_number(),err:TransactionErrorResult,memo:index_es_nullable(index_es_string()),blockTime:optional(index_es_nullable(index_es_number()))}))),type({subscription:index_es_number(),result:notificationResultAndContext(AccountInfoResult)}),type({pubkey:PublicKeyFromString,account:AccountInfoResult})),SlotInfoResult=(type({subscription:index_es_number(),result:notificationResultAndContext(ProgramAccountInfoResult)}),type({parent:index_es_number(),slot:index_es_number(),root:index_es_number()})),SlotUpdateResult=(type({subscription:index_es_number(),result:SlotInfoResult}),union([type({type:union([literal("firstShredReceived"),literal("completed"),literal("optimisticConfirmation"),literal("root")]),slot:index_es_number(),timestamp:index_es_number()}),type({type:literal("createdBank"),parent:index_es_number(),slot:index_es_number(),timestamp:index_es_number()}),type({type:literal("frozen"),slot:index_es_number(),timestamp:index_es_number(),stats:type({numTransactionEntries:index_es_number(),numSuccessfulTransactions:index_es_number(),numFailedTransactions:index_es_number(),maxTransactionsPerEntry:index_es_number()})}),type({type:literal("dead"),slot:index_es_number(),timestamp:index_es_number(),err:index_es_string()})])),VoteAccountInfoResult=(type({subscription:index_es_number(),result:SlotUpdateResult}),type({subscription:index_es_number(),result:notificationResultAndContext(union([SignatureStatusResult,SignatureReceivedResult]))}),type({subscription:index_es_number(),result:index_es_number()}),type({pubkey:index_es_string(),gossip:index_es_nullable(index_es_string()),tpu:index_es_nullable(index_es_string()),rpc:index_es_nullable(index_es_string()),version:index_es_nullable(index_es_string())}),type({votePubkey:index_es_string(),nodePubkey:index_es_string(),activatedStake:index_es_number(),epochVoteAccount:index_es_boolean(),epochCredits:index_es_array(tuple([index_es_number(),index_es_number(),index_es_number()])),commission:index_es_number(),lastVote:index_es_number(),rootSlot:index_es_nullable(index_es_number())})),ConfirmationStatus=(jsonRpcResult(type({current:index_es_array(VoteAccountInfoResult),delinquent:index_es_array(VoteAccountInfoResult)})),union([literal("processed"),literal("confirmed"),literal("finalized")])),SignatureStatusResponse=type({slot:index_es_number(),confirmations:index_es_nullable(index_es_number()),err:TransactionErrorResult,confirmationStatus:optional(ConfirmationStatus)}),AddressTableLookupStruct=(jsonRpcResultAndContext(index_es_array(index_es_nullable(SignatureStatusResponse))),jsonRpcResult(index_es_number()),type({accountKey:PublicKeyFromString,writableIndexes:index_es_array(index_es_number()),readonlyIndexes:index_es_array(index_es_number())})),ConfirmedTransactionResult=type({signatures:index_es_array(index_es_string()),message:type({accountKeys:index_es_array(index_es_string()),header:type({numRequiredSignatures:index_es_number(),numReadonlySignedAccounts:index_es_number(),numReadonlyUnsignedAccounts:index_es_number()}),instructions:index_es_array(type({accounts:index_es_array(index_es_number()),data:index_es_string(),programIdIndex:index_es_number()})),recentBlockhash:index_es_string(),addressTableLookups:optional(index_es_array(AddressTableLookupStruct))})}),AnnotatedAccountKey=type({pubkey:PublicKeyFromString,signer:index_es_boolean(),writable:index_es_boolean(),source:optional(union([literal("transaction"),literal("lookupTable")]))}),ConfirmedTransactionAccountsModeResult=type({accountKeys:index_es_array(AnnotatedAccountKey),signatures:index_es_array(index_es_string())}),ParsedInstructionResult=type({parsed:unknown(),program:index_es_string(),programId:PublicKeyFromString}),RawInstructionResult=type({accounts:index_es_array(PublicKeyFromString),data:index_es_string(),programId:PublicKeyFromString}),ParsedOrRawInstruction=coerce(union([RawInstructionResult,ParsedInstructionResult]),union([type({parsed:unknown(),program:index_es_string(),programId:index_es_string()}),type({accounts:index_es_array(index_es_string()),data:index_es_string(),programId:index_es_string()})]),(value=>index_es_create(value,"accounts"in value?RawInstructionResult:ParsedInstructionResult))),ParsedConfirmedTransactionResult=type({signatures:index_es_array(index_es_string()),message:type({accountKeys:index_es_array(AnnotatedAccountKey),instructions:index_es_array(ParsedOrRawInstruction),recentBlockhash:index_es_string(),addressTableLookups:optional(index_es_nullable(index_es_array(AddressTableLookupStruct)))})}),TokenBalanceResult=type({accountIndex:index_es_number(),mint:index_es_string(),owner:optional(index_es_string()),uiTokenAmount:TokenAmountResult}),LoadedAddressesResult=type({writable:index_es_array(PublicKeyFromString),readonly:index_es_array(PublicKeyFromString)}),ConfirmedTransactionMetaResult=type({err:TransactionErrorResult,fee:index_es_number(),innerInstructions:optional(index_es_nullable(index_es_array(type({index:index_es_number(),instructions:index_es_array(type({accounts:index_es_array(index_es_number()),data:index_es_string(),programIdIndex:index_es_number()}))})))),preBalances:index_es_array(index_es_number()),postBalances:index_es_array(index_es_number()),logMessages:optional(index_es_nullable(index_es_array(index_es_string()))),preTokenBalances:optional(index_es_nullable(index_es_array(TokenBalanceResult))),postTokenBalances:optional(index_es_nullable(index_es_array(TokenBalanceResult))),loadedAddresses:optional(LoadedAddressesResult),computeUnitsConsumed:optional(index_es_number())}),ParsedConfirmedTransactionMetaResult=type({err:TransactionErrorResult,fee:index_es_number(),innerInstructions:optional(index_es_nullable(index_es_array(type({index:index_es_number(),instructions:index_es_array(ParsedOrRawInstruction)})))),preBalances:index_es_array(index_es_number()),postBalances:index_es_array(index_es_number()),logMessages:optional(index_es_nullable(index_es_array(index_es_string()))),preTokenBalances:optional(index_es_nullable(index_es_array(TokenBalanceResult))),postTokenBalances:optional(index_es_nullable(index_es_array(TokenBalanceResult))),loadedAddresses:optional(LoadedAddressesResult),computeUnitsConsumed:optional(index_es_number())}),TransactionVersionStruct=union([literal(0),literal("legacy")]),RewardsResult=type({pubkey:index_es_string(),lamports:index_es_number(),postBalance:index_es_nullable(index_es_number()),rewardType:index_es_nullable(index_es_string()),commission:optional(index_es_nullable(index_es_number()))}),LogsResult=(jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),transactions:index_es_array(type({transaction:ConfirmedTransactionResult,meta:index_es_nullable(ConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number()),blockHeight:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number()),blockHeight:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),transactions:index_es_array(type({transaction:ConfirmedTransactionAccountsModeResult,meta:index_es_nullable(ConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number()),blockHeight:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),transactions:index_es_array(type({transaction:ParsedConfirmedTransactionResult,meta:index_es_nullable(ParsedConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number()),blockHeight:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),transactions:index_es_array(type({transaction:ConfirmedTransactionAccountsModeResult,meta:index_es_nullable(ParsedConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number()),blockHeight:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number()),blockHeight:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),transactions:index_es_array(type({transaction:ConfirmedTransactionResult,meta:index_es_nullable(ConfirmedTransactionMetaResult)})),rewards:optional(index_es_array(RewardsResult)),blockTime:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({blockhash:index_es_string(),previousBlockhash:index_es_string(),parentSlot:index_es_number(),signatures:index_es_array(index_es_string()),blockTime:index_es_nullable(index_es_number())}))),jsonRpcResult(index_es_nullable(type({slot:index_es_number(),meta:index_es_nullable(ConfirmedTransactionMetaResult),blockTime:optional(index_es_nullable(index_es_number())),transaction:ConfirmedTransactionResult,version:optional(TransactionVersionStruct)}))),jsonRpcResult(index_es_nullable(type({slot:index_es_number(),transaction:ParsedConfirmedTransactionResult,meta:index_es_nullable(ParsedConfirmedTransactionMetaResult),blockTime:optional(index_es_nullable(index_es_number())),version:optional(TransactionVersionStruct)}))),jsonRpcResultAndContext(type({blockhash:index_es_string(),feeCalculator:type({lamportsPerSignature:index_es_number()})})),jsonRpcResultAndContext(type({blockhash:index_es_string(),lastValidBlockHeight:index_es_number()})),jsonRpcResultAndContext(index_es_boolean()),jsonRpcResult(index_es_array(type({slot:index_es_number(),numTransactions:index_es_number(),numSlots:index_es_number(),samplePeriodSecs:index_es_number()}))),jsonRpcResultAndContext(index_es_nullable(type({feeCalculator:type({lamportsPerSignature:index_es_number()})}))),jsonRpcResult(index_es_string()),jsonRpcResult(index_es_string()),type({err:TransactionErrorResult,logs:index_es_array(index_es_string()),signature:index_es_string()}));type({result:notificationResultAndContext(LogsResult),subscription:index_es_number()});class Keypair{constructor(keypair){this._keypair=void 0,this._keypair=keypair??generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(secretKey,options){if(64!==secretKey.byteLength)throw new Error("bad secret key size");const publicKey=secretKey.slice(32,64);if(!options||!options.skipValidation){const privateScalar=secretKey.slice(0,32),computedPublicKey=getPublicKey(privateScalar);for(let ii=0;ii<32;ii++)if(publicKey[ii]!==computedPublicKey[ii])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey,secretKey})}static fromSeed(seed){const publicKey=getPublicKey(seed),secretKey=new Uint8Array(64);return secretKey.set(seed),secretKey.set(publicKey,32),new Keypair({publicKey,secretKey})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const LOOKUP_TABLE_INSTRUCTION_LAYOUTS=Object.freeze({CreateLookupTable:{index:0,layout:Layout.n_([Layout.Jq("instruction"),index_browser_esm_u64("recentSlot"),Layout.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:Layout.n_([Layout.Jq("instruction")])},ExtendLookupTable:{index:2,layout:Layout.n_([Layout.Jq("instruction"),index_browser_esm_u64(),Layout.A9(publicKey(),Layout.cv(Layout.Jq(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:Layout.n_([Layout.Jq("instruction")])},CloseLookupTable:{index:4,layout:Layout.n_([Layout.Jq("instruction")])}});class AddressLookupTableProgram{constructor(){}static createLookupTable(params){const[lookupTableAddress,bumpSeed]=PublicKey.findProgramAddressSync([params.authority.toBuffer(),(0,browser.k$)(BigInt(params.recentSlot),8)],this.programId),data=encodeData(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,{recentSlot:BigInt(params.recentSlot),bumpSeed}),keys=[{pubkey:lookupTableAddress,isSigner:!1,isWritable:!0},{pubkey:params.authority,isSigner:!0,isWritable:!1},{pubkey:params.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys,data}),lookupTableAddress]}static freezeLookupTable(params){const data=encodeData(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable),keys=[{pubkey:params.lookupTable,isSigner:!1,isWritable:!0},{pubkey:params.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys,data})}static extendLookupTable(params){const data=encodeData(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,{addresses:params.addresses.map((addr=>addr.toBytes()))}),keys=[{pubkey:params.lookupTable,isSigner:!1,isWritable:!0},{pubkey:params.authority,isSigner:!0,isWritable:!1}];return params.payer&&keys.push({pubkey:params.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys,data})}static deactivateLookupTable(params){const data=encodeData(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable),keys=[{pubkey:params.lookupTable,isSigner:!1,isWritable:!0},{pubkey:params.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys,data})}static closeLookupTable(params){const data=encodeData(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable),keys=[{pubkey:params.lookupTable,isSigner:!1,isWritable:!0},{pubkey:params.authority,isSigner:!0,isWritable:!1},{pubkey:params.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys,data})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS=Object.freeze({RequestUnits:{index:0,layout:Layout.n_([Layout.u8("instruction"),Layout.Jq("units"),Layout.Jq("additionalFee")])},RequestHeapFrame:{index:1,layout:Layout.n_([Layout.u8("instruction"),Layout.Jq("bytes")])},SetComputeUnitLimit:{index:2,layout:Layout.n_([Layout.u8("instruction"),Layout.Jq("units")])},SetComputeUnitPrice:{index:3,layout:Layout.n_([Layout.u8("instruction"),index_browser_esm_u64("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(params){const data=encodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,params);return new TransactionInstruction({keys:[],programId:this.programId,data})}static requestHeapFrame(params){const data=encodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,params);return new TransactionInstruction({keys:[],programId:this.programId,data})}static setComputeUnitLimit(params){const data=encodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,params);return new TransactionInstruction({keys:[],programId:this.programId,data})}static setComputeUnitPrice(params){const data=encodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,{microLamports:BigInt(params.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const ED25519_INSTRUCTION_LAYOUT=Layout.n_([Layout.u8("numSignatures"),Layout.u8("padding"),Layout.KB("signatureOffset"),Layout.KB("signatureInstructionIndex"),Layout.KB("publicKeyOffset"),Layout.KB("publicKeyInstructionIndex"),Layout.KB("messageDataOffset"),Layout.KB("messageDataSize"),Layout.KB("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(params){const{publicKey,message,signature,instructionIndex}=params;index_browser_esm_assert(32===publicKey.length,`Public Key must be 32 bytes but received ${publicKey.length} bytes`),index_browser_esm_assert(64===signature.length,`Signature must be 64 bytes but received ${signature.length} bytes`);const publicKeyOffset=ED25519_INSTRUCTION_LAYOUT.span,signatureOffset=publicKeyOffset+publicKey.length,messageDataOffset=signatureOffset+signature.length,instructionData=node_modules_buffer.Buffer.alloc(messageDataOffset+message.length),index=null==instructionIndex?65535:instructionIndex;return ED25519_INSTRUCTION_LAYOUT.encode({numSignatures:1,padding:0,signatureOffset,signatureInstructionIndex:index,publicKeyOffset,publicKeyInstructionIndex:index,messageDataOffset,messageDataSize:message.length,messageInstructionIndex:index},instructionData),instructionData.fill(publicKey,publicKeyOffset),instructionData.fill(signature,signatureOffset),instructionData.fill(message,messageDataOffset),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:instructionData})}static createInstructionWithPrivateKey(params){const{privateKey,message,instructionIndex}=params;index_browser_esm_assert(64===privateKey.length,`Private key must be 64 bytes but received ${privateKey.length} bytes`);try{const keypair=Keypair.fromSecretKey(privateKey),publicKey=keypair.publicKey.toBytes(),signature=sign(message,keypair.secretKey);return this.createInstructionWithPublicKey({publicKey,message,signature,instructionIndex})}catch(error){throw new Error(`Error creating instruction; ${error}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");secp256k1.utils.isValidPrivateKey;const publicKeyCreate=secp256k1.getPublicKey,SECP256K1_INSTRUCTION_LAYOUT=Layout.n_([Layout.u8("numSignatures"),Layout.KB("signatureOffset"),Layout.u8("signatureInstructionIndex"),Layout.KB("ethAddressOffset"),Layout.u8("ethAddressInstructionIndex"),Layout.KB("messageDataOffset"),Layout.KB("messageDataSize"),Layout.u8("messageInstructionIndex"),Layout.Ik(20,"ethAddress"),Layout.Ik(64,"signature"),Layout.u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(publicKey){index_browser_esm_assert(64===publicKey.length,`Public key must be 64 bytes but received ${publicKey.length} bytes`);try{return node_modules_buffer.Buffer.from(keccak_256(toBuffer(publicKey))).slice(-20)}catch(error){throw new Error(`Error constructing Ethereum address: ${error}`)}}static createInstructionWithPublicKey(params){const{publicKey,message,signature,recoveryId,instructionIndex}=params;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(publicKey),message,signature,recoveryId,instructionIndex})}static createInstructionWithEthAddress(params){const{ethAddress:rawAddress,message,signature,recoveryId,instructionIndex=0}=params;let ethAddress;ethAddress="string"==typeof rawAddress?rawAddress.startsWith("0x")?node_modules_buffer.Buffer.from(rawAddress.substr(2),"hex"):node_modules_buffer.Buffer.from(rawAddress,"hex"):rawAddress,index_browser_esm_assert(20===ethAddress.length,`Address must be 20 bytes but received ${ethAddress.length} bytes`);const signatureOffset=12+ethAddress.length,messageDataOffset=signatureOffset+signature.length+1,instructionData=node_modules_buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span+message.length);return SECP256K1_INSTRUCTION_LAYOUT.encode({numSignatures:1,signatureOffset,signatureInstructionIndex:instructionIndex,ethAddressOffset:12,ethAddressInstructionIndex:instructionIndex,messageDataOffset,messageDataSize:message.length,messageInstructionIndex:instructionIndex,signature:toBuffer(signature),ethAddress:toBuffer(ethAddress),recoveryId},instructionData),instructionData.fill(toBuffer(message),SECP256K1_INSTRUCTION_LAYOUT.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:instructionData})}static createInstructionWithPrivateKey(params){const{privateKey:pkey,message,instructionIndex}=params;index_browser_esm_assert(32===pkey.length,`Private key must be 32 bytes but received ${pkey.length} bytes`);try{const privateKey=toBuffer(pkey),publicKey=publicKeyCreate(privateKey,!1).slice(1),messageHash=node_modules_buffer.Buffer.from(keccak_256(toBuffer(message))),[signature,recoveryId]=((msgHash,privKey)=>{const signature=secp256k1.sign(msgHash,privKey);return[signature.toCompactRawBytes(),signature.recovery]})(messageHash,privateKey);return this.createInstructionWithPublicKey({publicKey,message,signature,recoveryId,instructionIndex})}catch(error){throw new Error(`Error creating instruction; ${error}`)}}}var _class2;Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const STAKE_CONFIG_ID=new PublicKey("StakeConfig11111111111111111111111111111111");class Lockup{constructor(unixTimestamp,epoch,custodian){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=unixTimestamp,this.epoch=epoch,this.custodian=custodian}}_class2=Lockup,Lockup.default=new _class2(0,0,PublicKey.default);const STAKE_INSTRUCTION_LAYOUTS=Object.freeze({Initialize:{index:0,layout:Layout.n_([Layout.Jq("instruction"),((property="authorized")=>Layout.n_([publicKey("staker"),publicKey("withdrawer")],property))(),((property="lockup")=>Layout.n_([Layout.gM("unixTimestamp"),Layout.gM("epoch"),publicKey("custodian")],property))()])},Authorize:{index:1,layout:Layout.n_([Layout.Jq("instruction"),publicKey("newAuthorized"),Layout.Jq("stakeAuthorizationType")])},Delegate:{index:2,layout:Layout.n_([Layout.Jq("instruction")])},Split:{index:3,layout:Layout.n_([Layout.Jq("instruction"),Layout.gM("lamports")])},Withdraw:{index:4,layout:Layout.n_([Layout.Jq("instruction"),Layout.gM("lamports")])},Deactivate:{index:5,layout:Layout.n_([Layout.Jq("instruction")])},Merge:{index:7,layout:Layout.n_([Layout.Jq("instruction")])},AuthorizeWithSeed:{index:8,layout:Layout.n_([Layout.Jq("instruction"),publicKey("newAuthorized"),Layout.Jq("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(params){const{stakePubkey,authorized,lockup:maybeLockup}=params,lockup=maybeLockup||Lockup.default,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Initialize,{authorized:{staker:toBuffer(authorized.staker.toBuffer()),withdrawer:toBuffer(authorized.withdrawer.toBuffer())},lockup:{unixTimestamp:lockup.unixTimestamp,epoch:lockup.epoch,custodian:toBuffer(lockup.custodian.toBuffer())}}),instructionData={keys:[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:this.programId,data};return new TransactionInstruction(instructionData)}static createAccountWithSeed(params){const transaction=new Transaction;transaction.add(SystemProgram.createAccountWithSeed({fromPubkey:params.fromPubkey,newAccountPubkey:params.stakePubkey,basePubkey:params.basePubkey,seed:params.seed,lamports:params.lamports,space:this.space,programId:this.programId}));const{stakePubkey,authorized,lockup}=params;return transaction.add(this.initialize({stakePubkey,authorized,lockup}))}static createAccount(params){const transaction=new Transaction;transaction.add(SystemProgram.createAccount({fromPubkey:params.fromPubkey,newAccountPubkey:params.stakePubkey,lamports:params.lamports,space:this.space,programId:this.programId}));const{stakePubkey,authorized,lockup}=params;return transaction.add(this.initialize({stakePubkey,authorized,lockup}))}static delegate(params){const{stakePubkey,authorizedPubkey,votePubkey}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate);return(new Transaction).add({keys:[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:votePubkey,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:STAKE_CONFIG_ID,isSigner:!1,isWritable:!1},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data})}static authorize(params){const{stakePubkey,authorizedPubkey,newAuthorizedPubkey,stakeAuthorizationType,custodianPubkey}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Authorize,{newAuthorized:toBuffer(newAuthorizedPubkey.toBuffer()),stakeAuthorizationType:stakeAuthorizationType.index}),keys=[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!0},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}];return custodianPubkey&&keys.push({pubkey:custodianPubkey,isSigner:!0,isWritable:!1}),(new Transaction).add({keys,programId:this.programId,data})}static authorizeWithSeed(params){const{stakePubkey,authorityBase,authoritySeed,authorityOwner,newAuthorizedPubkey,stakeAuthorizationType,custodianPubkey}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,{newAuthorized:toBuffer(newAuthorizedPubkey.toBuffer()),stakeAuthorizationType:stakeAuthorizationType.index,authoritySeed,authorityOwner:toBuffer(authorityOwner.toBuffer())}),keys=[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:authorityBase,isSigner:!0,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1}];return custodianPubkey&&keys.push({pubkey:custodianPubkey,isSigner:!0,isWritable:!1}),(new Transaction).add({keys,programId:this.programId,data})}static splitInstruction(params){const{stakePubkey,authorizedPubkey,splitStakePubkey,lamports}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Split,{lamports});return new TransactionInstruction({keys:[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:splitStakePubkey,isSigner:!1,isWritable:!0},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data})}static split(params,rentExemptReserve){const transaction=new Transaction;return transaction.add(SystemProgram.createAccount({fromPubkey:params.authorizedPubkey,newAccountPubkey:params.splitStakePubkey,lamports:rentExemptReserve,space:this.space,programId:this.programId})),transaction.add(this.splitInstruction(params))}static splitWithSeed(params,rentExemptReserve){const{stakePubkey,authorizedPubkey,splitStakePubkey,basePubkey,seed,lamports}=params,transaction=new Transaction;return transaction.add(SystemProgram.allocate({accountPubkey:splitStakePubkey,basePubkey,seed,space:this.space,programId:this.programId})),rentExemptReserve&&rentExemptReserve>0&&transaction.add(SystemProgram.transfer({fromPubkey:params.authorizedPubkey,toPubkey:splitStakePubkey,lamports:rentExemptReserve})),transaction.add(this.splitInstruction({stakePubkey,authorizedPubkey,splitStakePubkey,lamports}))}static merge(params){const{stakePubkey,sourceStakePubKey,authorizedPubkey}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Merge);return(new Transaction).add({keys:[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:sourceStakePubKey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data})}static withdraw(params){const{stakePubkey,authorizedPubkey,toPubkey,lamports,custodianPubkey}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Withdraw,{lamports}),keys=[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:toPubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}];return custodianPubkey&&keys.push({pubkey:custodianPubkey,isSigner:!0,isWritable:!1}),(new Transaction).add({keys,programId:this.programId,data})}static deactivate(params){const{stakePubkey,authorizedPubkey}=params,data=encodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate);return(new Transaction).add({keys:[{pubkey:stakePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111"),StakeProgram.space=200;const VOTE_INSTRUCTION_LAYOUTS=Object.freeze({InitializeAccount:{index:0,layout:Layout.n_([Layout.Jq("instruction"),((property="voteInit")=>Layout.n_([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),Layout.u8("commission")],property))()])},Authorize:{index:1,layout:Layout.n_([Layout.Jq("instruction"),publicKey("newAuthorized"),Layout.Jq("voteAuthorizationType")])},Withdraw:{index:3,layout:Layout.n_([Layout.Jq("instruction"),Layout.gM("lamports")])},UpdateValidatorIdentity:{index:4,layout:Layout.n_([Layout.Jq("instruction")])},AuthorizeWithSeed:{index:10,layout:Layout.n_([Layout.Jq("instruction"),((property="voteAuthorizeWithSeedArgs")=>Layout.n_([Layout.Jq("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],property))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(params){const{votePubkey,nodePubkey,voteInit}=params,data=encodeData(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount,{voteInit:{nodePubkey:toBuffer(voteInit.nodePubkey.toBuffer()),authorizedVoter:toBuffer(voteInit.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(voteInit.authorizedWithdrawer.toBuffer()),commission:voteInit.commission}}),instructionData={keys:[{pubkey:votePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:nodePubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data};return new TransactionInstruction(instructionData)}static createAccount(params){const transaction=new Transaction;return transaction.add(SystemProgram.createAccount({fromPubkey:params.fromPubkey,newAccountPubkey:params.votePubkey,lamports:params.lamports,space:this.space,programId:this.programId})),transaction.add(this.initializeAccount({votePubkey:params.votePubkey,nodePubkey:params.voteInit.nodePubkey,voteInit:params.voteInit}))}static authorize(params){const{votePubkey,authorizedPubkey,newAuthorizedPubkey,voteAuthorizationType}=params,data=encodeData(VOTE_INSTRUCTION_LAYOUTS.Authorize,{newAuthorized:toBuffer(newAuthorizedPubkey.toBuffer()),voteAuthorizationType:voteAuthorizationType.index}),keys=[{pubkey:votePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:authorizedPubkey,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys,programId:this.programId,data})}static authorizeWithSeed(params){const{currentAuthorityDerivedKeyBasePubkey,currentAuthorityDerivedKeyOwnerPubkey,currentAuthorityDerivedKeySeed,newAuthorizedPubkey,voteAuthorizationType,votePubkey}=params,data=encodeData(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),currentAuthorityDerivedKeySeed,newAuthorized:toBuffer(newAuthorizedPubkey.toBuffer()),voteAuthorizationType:voteAuthorizationType.index}}),keys=[{pubkey:votePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:currentAuthorityDerivedKeyBasePubkey,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys,programId:this.programId,data})}static withdraw(params){const{votePubkey,authorizedWithdrawerPubkey,lamports,toPubkey}=params,data=encodeData(VOTE_INSTRUCTION_LAYOUTS.Withdraw,{lamports}),keys=[{pubkey:votePubkey,isSigner:!1,isWritable:!0},{pubkey:toPubkey,isSigner:!1,isWritable:!0},{pubkey:authorizedWithdrawerPubkey,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys,programId:this.programId,data})}static safeWithdraw(params,currentVoteAccountBalance,rentExemptMinimum){if(params.lamports>currentVoteAccountBalance-rentExemptMinimum)throw new Error("Withdraw will leave vote account with insufficient funds.");return VoteProgram.withdraw(params)}static updateValidatorIdentity(params){const{votePubkey,authorizedWithdrawerPubkey,nodePubkey}=params,data=encodeData(VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity),keys=[{pubkey:votePubkey,isSigner:!1,isWritable:!0},{pubkey:nodePubkey,isSigner:!0,isWritable:!1},{pubkey:authorizedWithdrawerPubkey,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys,programId:this.programId,data})}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111"),VoteProgram.space=3762;new PublicKey("Va1idator1nfo111111111111111111111111111111"),type({name:index_es_string(),website:optional(index_es_string()),details:optional(index_es_string()),keybaseUsername:optional(index_es_string())});new PublicKey("Vote111111111111111111111111111111111111111"),Layout.n_([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),Layout.u8("commission"),Layout._O(),Layout.A9(Layout.n_([Layout._O("slot"),Layout.Jq("confirmationCount")]),Layout.cv(Layout.Jq(),-8),"votes"),Layout.u8("rootSlotValid"),Layout._O("rootSlot"),Layout._O(),Layout.A9(Layout.n_([Layout._O("epoch"),publicKey("authorizedVoter")]),Layout.cv(Layout.Jq(),-8),"authorizedVoters"),Layout.n_([Layout.A9(Layout.n_([publicKey("authorizedPubkey"),Layout._O("epochOfLastAuthorizedSwitch"),Layout._O("targetEpoch")]),32,"buf"),Layout._O("idx"),Layout.u8("isEmpty")],"priorVoters"),Layout._O(),Layout.A9(Layout.n_([Layout._O("epoch"),Layout._O("credits"),Layout._O("prevCredits")]),Layout.cv(Layout.Jq(),-8),"epochCredits"),Layout.n_([Layout._O("slot"),Layout._O("timestamp")],"lastTimestamp")])},"./node_modules/@solana/web3.js/node_modules/base-x/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var _Buffer=__webpack_require__("./node_modules/safe-buffer/index.js").Buffer;module.exports=function base(ALPHABET){if(ALPHABET.length>=255)throw new TypeError("Alphabet too long");for(var BASE_MAP=new Uint8Array(256),j=0;j<BASE_MAP.length;j++)BASE_MAP[j]=255;for(var i=0;i<ALPHABET.length;i++){var x=ALPHABET.charAt(i),xc=x.charCodeAt(0);if(255!==BASE_MAP[xc])throw new TypeError(x+" is ambiguous");BASE_MAP[xc]=i}var BASE=ALPHABET.length,LEADER=ALPHABET.charAt(0),FACTOR=Math.log(BASE)/Math.log(256),iFACTOR=Math.log(256)/Math.log(BASE);function decodeUnsafe(source){if("string"!=typeof source)throw new TypeError("Expected String");if(0===source.length)return _Buffer.alloc(0);for(var psz=0,zeroes=0,length=0;source[psz]===LEADER;)zeroes++,psz++;for(var size=(source.length-psz)*FACTOR+1>>>0,b256=new Uint8Array(size);source[psz];){var carry=BASE_MAP[source.charCodeAt(psz)];if(255===carry)return;for(var i=0,it3=size-1;(0!==carry||i<length)&&-1!==it3;it3--,i++)carry+=BASE*b256[it3]>>>0,b256[it3]=carry%256>>>0,carry=carry/256>>>0;if(0!==carry)throw new Error("Non-zero carry");length=i,psz++}for(var it4=size-length;it4!==size&&0===b256[it4];)it4++;var vch=_Buffer.allocUnsafe(zeroes+(size-it4));vch.fill(0,0,zeroes);for(var j=zeroes;it4!==size;)vch[j++]=b256[it4++];return vch}return{encode:function encode(source){if((Array.isArray(source)||source instanceof Uint8Array)&&(source=_Buffer.from(source)),!_Buffer.isBuffer(source))throw new TypeError("Expected Buffer");if(0===source.length)return"";for(var zeroes=0,length=0,pbegin=0,pend=source.length;pbegin!==pend&&0===source[pbegin];)pbegin++,zeroes++;for(var size=(pend-pbegin)*iFACTOR+1>>>0,b58=new Uint8Array(size);pbegin!==pend;){for(var carry=source[pbegin],i=0,it1=size-1;(0!==carry||i<length)&&-1!==it1;it1--,i++)carry+=256*b58[it1]>>>0,b58[it1]=carry%BASE>>>0,carry=carry/BASE>>>0;if(0!==carry)throw new Error("Non-zero carry");length=i,pbegin++}for(var it2=size-length;it2!==size&&0===b58[it2];)it2++;for(var str=LEADER.repeat(zeroes);it2<size;++it2)str+=ALPHABET.charAt(b58[it2]);return str},decodeUnsafe,decode:function decode(string){var buffer=decodeUnsafe(string);if(buffer)return buffer;throw new Error("Non-base"+BASE+" character")}}}},"./node_modules/@solana/web3.js/node_modules/bs58/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var basex=__webpack_require__("./node_modules/@solana/web3.js/node_modules/base-x/src/index.js");module.exports=basex("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},"./node_modules/bigint-buffer/dist/browser.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer;exports.oU=function toBigIntLE(buf){{const reversed=Buffer.from(buf);reversed.reverse();const hex=reversed.toString("hex");return 0===hex.length?BigInt(0):BigInt(`0x${hex}`)}},exports.Q5=function toBigIntBE(buf){{const hex=buf.toString("hex");return 0===hex.length?BigInt(0):BigInt(`0x${hex}`)}},exports.k$=function toBufferLE(num,width){{const hex=num.toString(16),buffer=Buffer.from(hex.padStart(2*width,"0").slice(0,2*width),"hex");return buffer.reverse(),buffer}},exports.zP=function toBufferBE(num,width){{const hex=num.toString(16);return Buffer.from(hex.padStart(2*width,"0").slice(0,2*width),"hex")}}},"./node_modules/borsh/lib/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";var Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer,__createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k),Object.defineProperty(o,k2,{enumerable:!0,get:function(){return m[k]}})}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,v){o.default=v}),__decorate=this&&this.__decorate||function(decorators,target,key,desc){var d,c=arguments.length,r=c<3?target:null===desc?desc=Object.getOwnPropertyDescriptor(target,key):desc;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)(d=decorators[i])&&(r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r);return c>3&&r&&Object.defineProperty(target,key,r),r},__importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);return __setModuleDefault(result,mod),result},__importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.deserializeUnchecked=exports.deserialize=exports.serialize=exports.BinaryReader=exports.BinaryWriter=exports.BorshError=exports.baseDecode=exports.baseEncode=void 0;const bn_js_1=__importDefault(__webpack_require__("./node_modules/bn.js/lib/bn.js")),bs58_1=__importDefault(__webpack_require__("./node_modules/borsh/node_modules/bs58/index.js")),encoding=__importStar(__webpack_require__("./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs")),textDecoder=new("function"!=typeof TextDecoder?encoding.TextDecoder:TextDecoder)("utf-8",{fatal:!0});exports.baseEncode=function baseEncode(value){return"string"==typeof value&&(value=Buffer.from(value,"utf8")),bs58_1.default.encode(Buffer.from(value))},exports.baseDecode=function baseDecode(value){return Buffer.from(bs58_1.default.decode(value))};class BorshError extends Error{constructor(message){super(message),this.fieldPath=[],this.originalMessage=message}addToFieldPath(fieldName){this.fieldPath.splice(0,0,fieldName),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}exports.BorshError=BorshError;class BinaryWriter{constructor(){this.buf=Buffer.alloc(1024),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(1024)]))}writeU8(value){this.maybeResize(),this.buf.writeUInt8(value,this.length),this.length+=1}writeU16(value){this.maybeResize(),this.buf.writeUInt16LE(value,this.length),this.length+=2}writeU32(value){this.maybeResize(),this.buf.writeUInt32LE(value,this.length),this.length+=4}writeU64(value){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le",8)))}writeU128(value){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le",16)))}writeU256(value){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le",32)))}writeU512(value){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le",64)))}writeBuffer(buffer){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),buffer,Buffer.alloc(1024)]),this.length+=buffer.length}writeString(str){this.maybeResize();const b=Buffer.from(str,"utf8");this.writeU32(b.length),this.writeBuffer(b)}writeFixedArray(array){this.writeBuffer(Buffer.from(array))}writeArray(array,fn){this.maybeResize(),this.writeU32(array.length);for(const elem of array)this.maybeResize(),fn(elem)}toArray(){return this.buf.subarray(0,this.length)}}function handlingRangeError(target,propertyKey,propertyDescriptor){const originalMethod=propertyDescriptor.value;propertyDescriptor.value=function(...args){try{return originalMethod.apply(this,args)}catch(e){if(e instanceof RangeError){const code=e.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(code)>=0)throw new BorshError("Reached the end of buffer when deserializing")}throw e}}}exports.BinaryWriter=BinaryWriter;class BinaryReader{constructor(buf){this.buf=buf,this.offset=0}readU8(){const value=this.buf.readUInt8(this.offset);return this.offset+=1,value}readU16(){const value=this.buf.readUInt16LE(this.offset);return this.offset+=2,value}readU32(){const value=this.buf.readUInt32LE(this.offset);return this.offset+=4,value}readU64(){const buf=this.readBuffer(8);return new bn_js_1.default(buf,"le")}readU128(){const buf=this.readBuffer(16);return new bn_js_1.default(buf,"le")}readU256(){const buf=this.readBuffer(32);return new bn_js_1.default(buf,"le")}readU512(){const buf=this.readBuffer(64);return new bn_js_1.default(buf,"le")}readBuffer(len){if(this.offset+len>this.buf.length)throw new BorshError(`Expected buffer length ${len} isn't within bounds`);const result=this.buf.slice(this.offset,this.offset+len);return this.offset+=len,result}readString(){const len=this.readU32(),buf=this.readBuffer(len);try{return textDecoder.decode(buf)}catch(e){throw new BorshError(`Error decoding UTF-8 string: ${e}`)}}readFixedArray(len){return new Uint8Array(this.readBuffer(len))}readArray(fn){const len=this.readU32(),result=Array();for(let i=0;i<len;++i)result.push(fn());return result}}function capitalizeFirstLetter(string){return string.charAt(0).toUpperCase()+string.slice(1)}function serializeField(schema,fieldName,value,fieldType,writer){try{if("string"==typeof fieldType)writer[`write${capitalizeFirstLetter(fieldType)}`](value);else if(fieldType instanceof Array)if("number"==typeof fieldType[0]){if(value.length!==fieldType[0])throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);writer.writeFixedArray(value)}else if(2===fieldType.length&&"number"==typeof fieldType[1]){if(value.length!==fieldType[1])throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);for(let i=0;i<fieldType[1];i++)serializeField(schema,null,value[i],fieldType[0],writer)}else writer.writeArray(value,(item=>{serializeField(schema,fieldName,item,fieldType[0],writer)}));else if(void 0!==fieldType.kind)switch(fieldType.kind){case"option":null==value?writer.writeU8(0):(writer.writeU8(1),serializeField(schema,fieldName,value,fieldType.type,writer));break;case"map":writer.writeU32(value.size),value.forEach(((val,key)=>{serializeField(schema,fieldName,key,fieldType.key,writer),serializeField(schema,fieldName,val,fieldType.value,writer)}));break;default:throw new BorshError(`FieldType ${fieldType} unrecognized`)}else serializeStruct(schema,value,writer)}catch(error){throw error instanceof BorshError&&error.addToFieldPath(fieldName),error}}function serializeStruct(schema,obj,writer){if("function"==typeof obj.borshSerialize)return void obj.borshSerialize(writer);const structSchema=schema.get(obj.constructor);if(!structSchema)throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);if("struct"===structSchema.kind)structSchema.fields.map((([fieldName,fieldType])=>{serializeField(schema,fieldName,obj[fieldName],fieldType,writer)}));else{if("enum"!==structSchema.kind)throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);{const name=obj[structSchema.field];for(let idx=0;idx<structSchema.values.length;++idx){const[fieldName,fieldType]=structSchema.values[idx];if(fieldName===name){writer.writeU8(idx),serializeField(schema,fieldName,obj[fieldName],fieldType,writer);break}}}}}function deserializeField(schema,fieldName,fieldType,reader){try{if("string"==typeof fieldType)return reader[`read${capitalizeFirstLetter(fieldType)}`]();if(fieldType instanceof Array){if("number"==typeof fieldType[0])return reader.readFixedArray(fieldType[0]);if("number"==typeof fieldType[1]){const arr=[];for(let i=0;i<fieldType[1];i++)arr.push(deserializeField(schema,null,fieldType[0],reader));return arr}return reader.readArray((()=>deserializeField(schema,fieldName,fieldType[0],reader)))}if("option"===fieldType.kind){return reader.readU8()?deserializeField(schema,fieldName,fieldType.type,reader):void 0}if("map"===fieldType.kind){let map=new Map;const length=reader.readU32();for(let i=0;i<length;i++){const key=deserializeField(schema,fieldName,fieldType.key,reader),val=deserializeField(schema,fieldName,fieldType.value,reader);map.set(key,val)}return map}return deserializeStruct(schema,fieldType,reader)}catch(error){throw error instanceof BorshError&&error.addToFieldPath(fieldName),error}}function deserializeStruct(schema,classType,reader){if("function"==typeof classType.borshDeserialize)return classType.borshDeserialize(reader);const structSchema=schema.get(classType);if(!structSchema)throw new BorshError(`Class ${classType.name} is missing in schema`);if("struct"===structSchema.kind){const result={};for(const[fieldName,fieldType]of schema.get(classType).fields)result[fieldName]=deserializeField(schema,fieldName,fieldType,reader);return new classType(result)}if("enum"===structSchema.kind){const idx=reader.readU8();if(idx>=structSchema.values.length)throw new BorshError(`Enum index: ${idx} is out of range`);const[fieldName,fieldType]=structSchema.values[idx];return new classType({[fieldName]:deserializeField(schema,fieldName,fieldType,reader)})}throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`)}__decorate([handlingRangeError],BinaryReader.prototype,"readU8",null),__decorate([handlingRangeError],BinaryReader.prototype,"readU16",null),__decorate([handlingRangeError],BinaryReader.prototype,"readU32",null),__decorate([handlingRangeError],BinaryReader.prototype,"readU64",null),__decorate([handlingRangeError],BinaryReader.prototype,"readU128",null),__decorate([handlingRangeError],BinaryReader.prototype,"readU256",null),__decorate([handlingRangeError],BinaryReader.prototype,"readU512",null),__decorate([handlingRangeError],BinaryReader.prototype,"readString",null),__decorate([handlingRangeError],BinaryReader.prototype,"readFixedArray",null),__decorate([handlingRangeError],BinaryReader.prototype,"readArray",null),exports.BinaryReader=BinaryReader,exports.serialize=function serialize(schema,obj,Writer=BinaryWriter){const writer=new Writer;return serializeStruct(schema,obj,writer),writer.toArray()},exports.deserialize=function deserialize(schema,classType,buffer,Reader=BinaryReader){const reader=new Reader(buffer),result=deserializeStruct(schema,classType,reader);if(reader.offset<buffer.length)throw new BorshError(`Unexpected ${buffer.length-reader.offset} bytes after deserialized data`);return result},exports.deserializeUnchecked=function deserializeUnchecked(schema,classType,buffer,Reader=BinaryReader){return deserializeStruct(schema,classType,new Reader(buffer))}},"./node_modules/borsh/node_modules/base-x/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var _Buffer=__webpack_require__("./node_modules/safe-buffer/index.js").Buffer;module.exports=function base(ALPHABET){if(ALPHABET.length>=255)throw new TypeError("Alphabet too long");for(var BASE_MAP=new Uint8Array(256),j=0;j<BASE_MAP.length;j++)BASE_MAP[j]=255;for(var i=0;i<ALPHABET.length;i++){var x=ALPHABET.charAt(i),xc=x.charCodeAt(0);if(255!==BASE_MAP[xc])throw new TypeError(x+" is ambiguous");BASE_MAP[xc]=i}var BASE=ALPHABET.length,LEADER=ALPHABET.charAt(0),FACTOR=Math.log(BASE)/Math.log(256),iFACTOR=Math.log(256)/Math.log(BASE);function decodeUnsafe(source){if("string"!=typeof source)throw new TypeError("Expected String");if(0===source.length)return _Buffer.alloc(0);for(var psz=0,zeroes=0,length=0;source[psz]===LEADER;)zeroes++,psz++;for(var size=(source.length-psz)*FACTOR+1>>>0,b256=new Uint8Array(size);source[psz];){var carry=BASE_MAP[source.charCodeAt(psz)];if(255===carry)return;for(var i=0,it3=size-1;(0!==carry||i<length)&&-1!==it3;it3--,i++)carry+=BASE*b256[it3]>>>0,b256[it3]=carry%256>>>0,carry=carry/256>>>0;if(0!==carry)throw new Error("Non-zero carry");length=i,psz++}for(var it4=size-length;it4!==size&&0===b256[it4];)it4++;var vch=_Buffer.allocUnsafe(zeroes+(size-it4));vch.fill(0,0,zeroes);for(var j=zeroes;it4!==size;)vch[j++]=b256[it4++];return vch}return{encode:function encode(source){if((Array.isArray(source)||source instanceof Uint8Array)&&(source=_Buffer.from(source)),!_Buffer.isBuffer(source))throw new TypeError("Expected Buffer");if(0===source.length)return"";for(var zeroes=0,length=0,pbegin=0,pend=source.length;pbegin!==pend&&0===source[pbegin];)pbegin++,zeroes++;for(var size=(pend-pbegin)*iFACTOR+1>>>0,b58=new Uint8Array(size);pbegin!==pend;){for(var carry=source[pbegin],i=0,it1=size-1;(0!==carry||i<length)&&-1!==it1;it1--,i++)carry+=256*b58[it1]>>>0,b58[it1]=carry%BASE>>>0,carry=carry/BASE>>>0;if(0!==carry)throw new Error("Non-zero carry");length=i,pbegin++}for(var it2=size-length;it2!==size&&0===b58[it2];)it2++;for(var str=LEADER.repeat(zeroes);it2<size;++it2)str+=ALPHABET.charAt(b58[it2]);return str},decodeUnsafe,decode:function decode(string){var buffer=decodeUnsafe(string);if(buffer)return buffer;throw new Error("Non-base"+BASE+" character")}}}},"./node_modules/borsh/node_modules/bs58/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var basex=__webpack_require__("./node_modules/borsh/node_modules/base-x/src/index.js");module.exports=basex("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},"./node_modules/jayson/lib/client/browser/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const uuid=__webpack_require__("./node_modules/uuid/dist/esm-browser/index.js").v4,generateRequest=__webpack_require__("./node_modules/jayson/lib/generateRequest.js"),ClientBrowser=function(callServer,options){if(!(this instanceof ClientBrowser))return new ClientBrowser(callServer,options);options||(options={}),this.options={reviver:void 0!==options.reviver?options.reviver:null,replacer:void 0!==options.replacer?options.replacer:null,generator:void 0!==options.generator?options.generator:function(){return uuid()},version:void 0!==options.version?options.version:2,notificationIdNull:"boolean"==typeof options.notificationIdNull&&options.notificationIdNull},this.callServer=callServer};module.exports=ClientBrowser,ClientBrowser.prototype.request=function(method,params,id,callback){const self=this;let request=null;const isBatch=Array.isArray(method)&&"function"==typeof params;if(1===this.options.version&&isBatch)throw new TypeError("JSON-RPC 1.0 does not support batching");if(isBatch||!isBatch&&method&&"object"==typeof method&&"function"==typeof params)callback=params,request=method;else{"function"==typeof id&&(callback=id,id=void 0);const hasCallback="function"==typeof callback;try{request=generateRequest(method,params,id,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(err){if(hasCallback)return callback(err);throw err}if(!hasCallback)return request}let message;try{message=JSON.stringify(request,this.options.replacer)}catch(err){return callback(err)}return this.callServer(message,(function(err,response){self._parseResponse(err,response,callback)})),request},ClientBrowser.prototype._parseResponse=function(err,responseText,callback){if(err)return void callback(err);if(!responseText)return callback();let response;try{response=JSON.parse(responseText,this.options.reviver)}catch(err){return callback(err)}if(3===callback.length){if(Array.isArray(response)){const isError=function(res){return void 0!==res.error},isNotError=function(res){return!isError(res)};return callback(null,response.filter(isError),response.filter(isNotError))}return callback(null,response.error,response.result)}callback(null,response)}},"./node_modules/jayson/lib/generateRequest.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const uuid=__webpack_require__("./node_modules/uuid/dist/esm-browser/index.js").v4;module.exports=function(method,params,id,options){if("string"!=typeof method)throw new TypeError(method+" must be a string");const version="number"==typeof(options=options||{}).version?options.version:2;if(1!==version&&2!==version)throw new TypeError(version+" must be 1 or 2");const request={method};if(2===version&&(request.jsonrpc="2.0"),params){if("object"!=typeof params&&!Array.isArray(params))throw new TypeError(params+" must be an object, array or omitted");request.params=params}if(void 0===id){const generator="function"==typeof options.generator?options.generator:function(){return uuid()};request.id=generator(request,options)}else 2===version&&null===id?options.notificationIdNull&&(request.id=null):request.id=id;return request}},"./node_modules/rpc-websockets/dist/lib/client.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer,_interopRequireDefault=__webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");var _regenerator=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js")),_asyncToGenerator2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/asyncToGenerator.js")),_typeof2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js")),_classCallCheck2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js")),_createClass2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js")),_possibleConstructorReturn2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js")),_getPrototypeOf2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js")),_inherits2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js")),_eventemitter=__webpack_require__("./node_modules/rpc-websockets/node_modules/eventemitter3/index.js"),_utils=__webpack_require__("./node_modules/rpc-websockets/dist/lib/utils.js");function _callSuper(t,o,e){return o=(0,_getPrototypeOf2.default)(o),(0,_possibleConstructorReturn2.default)(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],(0,_getPrototypeOf2.default)(t).constructor):o.apply(t,e))}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t})()}var __rest=function(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(null!=s&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]])}return t};_eventemitter.EventEmitter},"./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var _interopRequireDefault=__webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");var _classCallCheck2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js")),_createClass2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js")),_possibleConstructorReturn2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js")),_getPrototypeOf2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js")),_inherits2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));function _callSuper(t,o,e){return o=(0,_getPrototypeOf2.default)(o),(0,_possibleConstructorReturn2.default)(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],(0,_getPrototypeOf2.default)(t).constructor):o.apply(t,e))}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t})()}var WebSocketBrowserImpl=function(_EventEmitter){function WebSocketBrowserImpl(address,options,protocols){var _this;return(0,_classCallCheck2.default)(this,WebSocketBrowserImpl),(_this=_callSuper(this,WebSocketBrowserImpl)).socket=new window.WebSocket(address,protocols),_this.socket.onopen=function(){return _this.emit("open")},_this.socket.onmessage=function(event){return _this.emit("message",event.data)},_this.socket.onerror=function(error){return _this.emit("error",error)},_this.socket.onclose=function(event){_this.emit("close",event.code,event.reason)},_this}return(0,_inherits2.default)(WebSocketBrowserImpl,_EventEmitter),(0,_createClass2.default)(WebSocketBrowserImpl,[{key:"send",value:function send(data,optionsOrCallback,callback){var cb=callback||optionsOrCallback;try{this.socket.send(data),cb()}catch(error){cb(error)}}},{key:"close",value:function close(code,reason){this.socket.close(code,reason)}},{key:"addEventListener",value:function addEventListener(type,listener,options){this.socket.addEventListener(type,listener,options)}}])}(__webpack_require__("./node_modules/rpc-websockets/node_modules/eventemitter3/index.js").EventEmitter)},"./node_modules/rpc-websockets/dist/lib/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var _interopRequireDefault=__webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports,"__esModule",{value:!0}),exports.DefaultDataPack=void 0,exports.createError=function createError(code,details){var error={code,message:errors.get(code)||"Internal Server Error"};details&&(error.data=details);return error};var _classCallCheck2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js")),_createClass2=_interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js")),errors=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]);exports.DefaultDataPack=function(){return(0,_createClass2.default)((function DefaultDataPack(){(0,_classCallCheck2.default)(this,DefaultDataPack)}),[{key:"encode",value:function encode(value){return JSON.stringify(value)}},{key:"decode",value:function decode(value){return JSON.parse(value)}}])}()},"./node_modules/rpc-websockets/node_modules/eventemitter3/index.js":module=>{"use strict";var has=Object.prototype.hasOwnProperty,prefix="~";function Events(){}function EE(fn,context,once){this.fn=fn,this.context=context,this.once=once||!1}function addListener(emitter,event,fn,context,once){if("function"!=typeof fn)throw new TypeError("The listener must be a function");var listener=new EE(fn,context||emitter,once),evt=prefix?prefix+event:event;return emitter._events[evt]?emitter._events[evt].fn?emitter._events[evt]=[emitter._events[evt],listener]:emitter._events[evt].push(listener):(emitter._events[evt]=listener,emitter._eventsCount++),emitter}function clearEvent(emitter,evt){0==--emitter._eventsCount?emitter._events=new Events:delete emitter._events[evt]}function EventEmitter(){this._events=new Events,this._eventsCount=0}Object.create&&(Events.prototype=Object.create(null),(new Events).__proto__||(prefix=!1)),EventEmitter.prototype.eventNames=function eventNames(){var events,name,names=[];if(0===this._eventsCount)return names;for(name in events=this._events)has.call(events,name)&&names.push(prefix?name.slice(1):name);return Object.getOwnPropertySymbols?names.concat(Object.getOwnPropertySymbols(events)):names},EventEmitter.prototype.listeners=function listeners(event){var evt=prefix?prefix+event:event,handlers=this._events[evt];if(!handlers)return[];if(handlers.fn)return[handlers.fn];for(var i=0,l=handlers.length,ee=new Array(l);i<l;i++)ee[i]=handlers[i].fn;return ee},EventEmitter.prototype.listenerCount=function listenerCount(event){var evt=prefix?prefix+event:event,listeners=this._events[evt];return listeners?listeners.fn?1:listeners.length:0},EventEmitter.prototype.emit=function emit(event,a1,a2,a3,a4,a5){var evt=prefix?prefix+event:event;if(!this._events[evt])return!1;var args,i,listeners=this._events[evt],len=arguments.length;if(listeners.fn){switch(listeners.once&&this.removeListener(event,listeners.fn,void 0,!0),len){case 1:return listeners.fn.call(listeners.context),!0;case 2:return listeners.fn.call(listeners.context,a1),!0;case 3:return listeners.fn.call(listeners.context,a1,a2),!0;case 4:return listeners.fn.call(listeners.context,a1,a2,a3),!0;case 5:return listeners.fn.call(listeners.context,a1,a2,a3,a4),!0;case 6:return listeners.fn.call(listeners.context,a1,a2,a3,a4,a5),!0}for(i=1,args=new Array(len-1);i<len;i++)args[i-1]=arguments[i];listeners.fn.apply(listeners.context,args)}else{var j,length=listeners.length;for(i=0;i<length;i++)switch(listeners[i].once&&this.removeListener(event,listeners[i].fn,void 0,!0),len){case 1:listeners[i].fn.call(listeners[i].context);break;case 2:listeners[i].fn.call(listeners[i].context,a1);break;case 3:listeners[i].fn.call(listeners[i].context,a1,a2);break;case 4:listeners[i].fn.call(listeners[i].context,a1,a2,a3);break;default:if(!args)for(j=1,args=new Array(len-1);j<len;j++)args[j-1]=arguments[j];listeners[i].fn.apply(listeners[i].context,args)}}return!0},EventEmitter.prototype.on=function on(event,fn,context){return addListener(this,event,fn,context,!1)},EventEmitter.prototype.once=function once(event,fn,context){return addListener(this,event,fn,context,!0)},EventEmitter.prototype.removeListener=function removeListener(event,fn,context,once){var evt=prefix?prefix+event:event;if(!this._events[evt])return this;if(!fn)return clearEvent(this,evt),this;var listeners=this._events[evt];if(listeners.fn)listeners.fn!==fn||once&&!listeners.once||context&&listeners.context!==context||clearEvent(this,evt);else{for(var i=0,events=[],length=listeners.length;i<length;i++)(listeners[i].fn!==fn||once&&!listeners[i].once||context&&listeners[i].context!==context)&&events.push(listeners[i]);events.length?this._events[evt]=1===events.length?events[0]:events:clearEvent(this,evt)}return this},EventEmitter.prototype.removeAllListeners=function removeAllListeners(event){var evt;return event?(evt=prefix?prefix+event:event,this._events[evt]&&clearEvent(this,evt)):(this._events=new Events,this._eventsCount=0),this},EventEmitter.prototype.off=EventEmitter.prototype.removeListener,EventEmitter.prototype.addListener=EventEmitter.prototype.on,EventEmitter.prefixed=prefix,EventEmitter.EventEmitter=EventEmitter,module.exports=EventEmitter},"./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function inRange(a,min,max){return min<=a&&a<=max}function ToDictionary(o){if(void 0===o)return{};if(o===Object(o))return o;throw TypeError("Could not convert argument to dictionary")}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{TextDecoder:()=>TextDecoder,TextEncoder:()=>TextEncoder});function Stream(tokens){this.tokens=[].slice.call(tokens)}Stream.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():-1},prepend:function(token){if(Array.isArray(token))for(var tokens=token;tokens.length;)this.tokens.unshift(tokens.pop());else this.tokens.unshift(token)},push:function(token){if(Array.isArray(token))for(var tokens=token;tokens.length;)this.tokens.push(tokens.shift());else this.tokens.push(token)}};function decoderError(fatal,opt_code_point){if(fatal)throw TypeError("Decoder error");return opt_code_point||65533}var DEFAULT_ENCODING="utf-8";function TextDecoder(encoding,options){if(!(this instanceof TextDecoder))return new TextDecoder(encoding,options);if((encoding=void 0!==encoding?String(encoding).toLowerCase():DEFAULT_ENCODING)!==DEFAULT_ENCODING)throw new Error("Encoding not supported. Only utf-8 is supported");options=ToDictionary(options),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(options.fatal),this._ignoreBOM=Boolean(options.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}function TextEncoder(encoding,options){if(!(this instanceof TextEncoder))return new TextEncoder(encoding,options);if((encoding=void 0!==encoding?String(encoding).toLowerCase():DEFAULT_ENCODING)!==DEFAULT_ENCODING)throw new Error("Encoding not supported. Only utf-8 is supported");options=ToDictionary(options),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(options.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}function UTF8Decoder(options){var fatal=options.fatal,utf8_code_point=0,utf8_bytes_seen=0,utf8_bytes_needed=0,utf8_lower_boundary=128,utf8_upper_boundary=191;this.handler=function(stream,bite){if(-1===bite&&0!==utf8_bytes_needed)return utf8_bytes_needed=0,decoderError(fatal);if(-1===bite)return-1;if(0===utf8_bytes_needed){if(inRange(bite,0,127))return bite;if(inRange(bite,194,223))utf8_bytes_needed=1,utf8_code_point=bite-192;else if(inRange(bite,224,239))224===bite&&(utf8_lower_boundary=160),237===bite&&(utf8_upper_boundary=159),utf8_bytes_needed=2,utf8_code_point=bite-224;else{if(!inRange(bite,240,244))return decoderError(fatal);240===bite&&(utf8_lower_boundary=144),244===bite&&(utf8_upper_boundary=143),utf8_bytes_needed=3,utf8_code_point=bite-240}return utf8_code_point<<=6*utf8_bytes_needed,null}if(!inRange(bite,utf8_lower_boundary,utf8_upper_boundary))return utf8_code_point=utf8_bytes_needed=utf8_bytes_seen=0,utf8_lower_boundary=128,utf8_upper_boundary=191,stream.prepend(bite),decoderError(fatal);if(utf8_lower_boundary=128,utf8_upper_boundary=191,utf8_code_point+=bite-128<<6*(utf8_bytes_needed-(utf8_bytes_seen+=1)),utf8_bytes_seen!==utf8_bytes_needed)return null;var code_point=utf8_code_point;return utf8_code_point=utf8_bytes_needed=utf8_bytes_seen=0,code_point}}function UTF8Encoder(options){options.fatal;this.handler=function(stream,code_point){if(-1===code_point)return-1;if(inRange(code_point,0,127))return code_point;var count,offset;inRange(code_point,128,2047)?(count=1,offset=192):inRange(code_point,2048,65535)?(count=2,offset=224):inRange(code_point,65536,1114111)&&(count=3,offset=240);for(var bytes=[(code_point>>6*count)+offset];count>0;){var temp=code_point>>6*(count-1);bytes.push(128|63&temp),count-=1}return bytes}}TextDecoder.prototype={decode:function decode(input,options){var bytes;bytes="object"==typeof input&&input instanceof ArrayBuffer?new Uint8Array(input):"object"==typeof input&&"buffer"in input&&input.buffer instanceof ArrayBuffer?new Uint8Array(input.buffer,input.byteOffset,input.byteLength):new Uint8Array(0),options=ToDictionary(options),this._streaming||(this._decoder=new UTF8Decoder({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(options.stream);for(var result,input_stream=new Stream(bytes),code_points=[];!input_stream.endOfStream()&&-1!==(result=this._decoder.handler(input_stream,input_stream.read()));)null!==result&&(Array.isArray(result)?code_points.push.apply(code_points,result):code_points.push(result));if(!this._streaming){do{if(-1===(result=this._decoder.handler(input_stream,input_stream.read())))break;null!==result&&(Array.isArray(result)?code_points.push.apply(code_points,result):code_points.push(result))}while(!input_stream.endOfStream());this._decoder=null}return code_points.length&&(-1===["utf-8"].indexOf(this.encoding)||this._ignoreBOM||this._BOMseen||(65279===code_points[0]?(this._BOMseen=!0,code_points.shift()):this._BOMseen=!0)),function codePointsToString(code_points){for(var s="",i=0;i<code_points.length;++i){var cp=code_points[i];cp<=65535?s+=String.fromCharCode(cp):(cp-=65536,s+=String.fromCharCode(55296+(cp>>10),56320+(1023&cp)))}return s}(code_points)}},TextEncoder.prototype={encode:function encode(opt_string,options){opt_string=opt_string?String(opt_string):"",options=ToDictionary(options),this._streaming||(this._encoder=new UTF8Encoder(this._options)),this._streaming=Boolean(options.stream);for(var result,bytes=[],input_stream=new Stream(function stringToCodePoints(string){for(var s=String(string),n=s.length,i=0,u=[];i<n;){var c=s.charCodeAt(i);if(c<55296||c>57343)u.push(c);else if(56320<=c&&c<=57343)u.push(65533);else if(55296<=c&&c<=56319)if(i===n-1)u.push(65533);else{var d=string.charCodeAt(i+1);if(56320<=d&&d<=57343){var a=1023&c,b=1023&d;u.push(65536+(a<<10)+b),i+=1}else u.push(65533)}i+=1}return u}(opt_string));!input_stream.endOfStream()&&-1!==(result=this._encoder.handler(input_stream,input_stream.read()));)Array.isArray(result)?bytes.push.apply(bytes,result):bytes.push(result);if(!this._streaming){for(;-1!==(result=this._encoder.handler(input_stream,input_stream.read()));)Array.isArray(result)?bytes.push.apply(bytes,result):bytes.push(result);this._encoder=null}return new Uint8Array(bytes)}}},"./node_modules/uuid/dist/esm-browser/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v4:()=>_v4_js__WEBPACK_IMPORTED_MODULE_0__.Z});var _v4_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/uuid/dist/esm-browser/v4.js")}}]);